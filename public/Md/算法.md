# 算法—基于java

### Deque双端队列（实现栈或者队列）

大多数Deque的实现没有对元素数量进行设限

| -         | 抛出异常      | 返回特殊值    |
| --------- | ------------- | ------------- |
| 插入      | addFirst(e)   | offerFirst(e) |
|           | addLast(e)    | offerLast(e)  |
| 提取/移除 | removeFirst() | pollFirst()   |
|           | removeLast()  | pollLast()    |
| 检索/检查 | getFirst()    | peekFirst()   |
|           | getLast()     | peekLast()    |

这个接口继承了Queue接口，当使用Deque作为Queue队列时，会产生FIFO（先进先出）行为

Queue方法等效Deque方法

| Queue     | Deque         |
| --------- | ------------- |
| add(e)    | addLast(e)    |
| offer(e)  | offerLast(e)  |
| remove()  | removeFirst() |
| poll()    | pollFirst()   |
| element() | getFirst()    |
| peek()    | peekFirst()   |

当其作为Stack栈时，就会产生LIFO（后进后出）行为（==应该优先使用这个类而不是历史遗留的java.util.Stack类==），此时Stack方法与其完全等效

| Stack   | Deque         |
| ------- | ------------- |
| push(e) | addFirst(e)   |
| pop()   | removeFirst() |
| peek()  | peekFirst()   |

**注意：**无论是作为Queue还是Stack，peek()方法都是有效的，元素都是从Deque头部读取

这个接口还提供了两个方法来移除内部元素`removeFirstOccurrence()`和`removeLastOccurrence()`

与java.util.List接口不同，该接口不支持对元素的索引访问

虽然没有禁止插入null，但最好不要这样做，它肯会被用作特殊方法得返回值导致一系列问题

其实现同城不定义`equals()`和`hashCode()`的基于元素版本的方法，而是从Object继承基于标识版本的方法

#### Deque的实现类

1. ArrayDeque

   一种可以改变大小的实现，非线程安全；如果没有外同步它不支持多线程并发访问。

   不允许元素为null，该类用作栈或者对列时，速度比Stack和LinkedList都要快

   该类和其迭代器实现了Collection接口和Iterator接口的所有可选方法

2. ConcurrentLinkedDeque

   一种基于链表的无边际并发Deque

   线程安全,一个ConcurrentLinkedListDeque是当多线程共享访问一个公共集合的有效选择。

   像很多并发集合实现一样，该类不允许元素为null

   Memory consistency effects(内存一致性效果)：和其他并发集合一样，线程中的将一个元素放进ConcurrentLinkedDeque的行为比另一个线程中访问或移除一个元素的优先级高。

   **注意问题：**

   - 如果使用ConcurrentLinkedDeque， 是否意味着我们不需要自己进行任何同步或加锁操作？

   并发集合的原子操作是同步的，换句话说就是每个对queue的单独调用是保证线程安全的，当执行非原子操作时，并不能保证线程安全的。例如只执行queue.add(e)或queue.poll()是线程安全的。但是非原子调用则不是自动线程安全的，如下段代码：

   ```java
   if(!queue.isEmpty()) {
       queue.poll(obj);
   }
   ```

   

   在queue.isEmpty()和queue.poll()之间可能会发生其他线程增加或移除元素，此时就需要自己增加同步锁：

   ```java
   Syncronized(queue) {
       if(!queue.isEmpty()) {
       queue.poll(obj);
       }
   }
   ```

   

   - 当同时有1000个请求时，能保证该类不会丢失吗？

   因为该类是一种无界限实现，所以无论你有多少同时发出的请求，queue不会遗失任何请求，因为queue的并发性，可能会超内存之类的，但队列本身实现不会成为限制因素的。在一个web应用中，可能会有其他丢失请求的可能，但queue的同步性不会成为原因之一。

   - 该类执行效果如何？

   通常，我们会讨论并发的正确性，也就是说，并发类保证它们是线程安全的（或者具有鲁棒性，不会出现死锁和饥饿等情况），对执行操作不做任何保证，而只是保证它们都是正确的。然而，ConcurrentLinkedDeque是一种wait-free实现，因此可能是性能最好的选择。

3. LinkedList

   List和Deque接口的双向链表实现，实现了所有可选列表操作，且允许所有类型的元素（包括null）。

   所有操作对于一个双向链表来说都可以实现（包括索引到某个元素）

   **注意**：

   该实现不是同步的，如果多线程并发地访问一个链表，并且至少有一个线程改变列表结构，则必须增加外部同步。这通常经过同步一些封装该列表的对象来实现。如果没有此类对象，则该列表必须用Collections.synchronizedList来包装，最好在创建时完成，以避免对列表意外的非同步访问。

   该类的方法iterator和listIterator返回的迭代器也是fail-fast的。

## 背包、队列和栈

（堆在优先队列中有讲）

背包（Bag）、队列（Queue）和栈（Stack）

它们的不同之处在于删除或者访问对象的顺序不同

### API

————————————————————————————————————————————————背包（不支持删除元素，目的是帮助收集用例并迭代遍历所有收集到的元素）                                                                                                                                                     ————————————————————————————————————————————————public class Bag<Item> implements Iterable<Item>

​                      Bag()                                   创建一个新背包

​            void  add()                                   添加一个元素

​     boolean  isEmpty()                           背包是否为空

​              int  size()                                   背包中的元素数量                                                                                              ————————————————————————————————————————————————先进先出（FIFO）队列                                                                                                                                       ————————————————————————————————————————————————public class Queue<Item> implements Iterable<Item>

​                      Queue()                              创建空队列

​            void  enqueue(Item item)        添加一个元素

​           Item  dequeue()                          删除最早添加的元素

​     Boolean  isEmpty()                          队列是否为空

​               int  size()                                  队列中的元素数量                                                                                ————————————————————————————————————————————————下压（后进先出，LIFO）栈                                                                                                                                 ————————————————————————————————————————————————public class Stack<Item> implements Iterable<Item>

​                      Stack()                               创建一个空栈

​            void  push()                                添加一个元素

​           Item  pop()                                  弹出最近添加的元素

​     boolean  isEmpty()                          栈是否为空

​               int  size()                                 栈中的元素数量                                                                                            ————————————————————————————————————————————————

### 背包实现

```java
import java.util.Iterator;

public class Bag<E> implements Iterable<E> {
    private E[] table;
    private static final int DEFAULT_SIZE=10;
    private int size;
    public Bag(){
        clear();
    }
    private void clear(){
        size=0;
        ensureCapacity(DEFAULT_SIZE);
    }
    public void add(E item){
        if (table.length==size()){
            ensureCapacity(2*size()+1);
        }
        table[size++]=item;
    }
    private void ensureCapacity(int newCapacity){
        if (newCapacity < size)return;
        else {
            E[] old=table;
            table=(E[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                table[i]=old[i];
            }
        }
    }
    public boolean isEmpty(){
        return size==0;
    }
    public int size(){
        return size;
    }
    public E get(int i){
        assert i<0||i>=size;
        return (E)table[i];
    }
    public Iterator<E> iterator(){
        return new BagIterator();
    }
    private class BagIterator implements Iterator<E>{
        private int index=0;
        public boolean hasNext(){
            return index<size();
        }
        public E next(){
            return (E) table[index++];
        }
        public void remove(){
            throw new UnsupportedOperationException();

        }
    }
}
```

背包可以用于复杂的统计计算

### 栈

后进先出（和弹夹一样），在计算机领域，栈具有基础而深远的影响

==栈使用Deque的实现类数表达式求值==

(1+((2+3)\*(4\*5)))

我们可以使用两个栈来对其进行解析

根据以下4中情况从左至右依次解析

1. 将操作数压入操作数栈
2. 将运算符压入运算符栈
3. 忽略左括号
4. 遇到右括号时弹出一个操作符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈

这样处理完最后一个右括号时，只会留下一个数，这个就是这个表达式的值

```java
package Stack;

import java.util.Scanner;
import java.util.Deque;

public class Evaluate {
    public static void main(String[] args) {
        Deque<String> ops=new ArrayDeque<>();
        Deque<Double> vals=new ArrayDeque<>();
        Scanner in =new Scanner(System.in);
        String str=in.nextLine();
        for (int i = 0; i < str.length(); i++) {
            String s=Character.toString(str.charAt(i));
            if (s.equals("("));//忽略左括号
            else if(s.equals("+")) ops.push(s);
            else if(s.equals("-")) ops.push(s);
            else if(s.equals("*")) ops.push(s);
            else if(s.equals("/")) ops.push(s);
            else if(s.equals("sqrt")) ops.push(s);
            else if(s.equals(")")) {
                String op= ops.pop();
                double v=vals.pop();
                if (op.equals("+")) v=vals.pop()+v;
                else if (op.equals("-")) v=vals.pop()-v;
                else if (op.equals("*")) v=vals.pop()*v;
                else if (op.equals("/")) v=vals.pop()/v;
                else if (op.equals("sqrt")) v=Math.sqrt(v);
                vals.push(v);
            }
            else vals.push(Double.parseDouble(s));
        }
        System.out.println(vals.pop());
    }
}
```

### 队列

先进先出

```java
public class Queue <Item> implements Iterable<Item>{
    private Node first;
    private Node last;
    private int N;

    private class Node{
        Item item;
        Node next;
    }
    public boolean isEmpty(){
        return first==null;
    }
    public int size(){
        return N;
    }
    public void enqueue(Item item){
        Node oldlast=last;
        last=new Node();
        last.item=item;
        last.next=null;
        if (isEmpty()) first=last;
        else oldlast.next=last;
        N++;
    }
    public Item dequeue(){
        Item item= first.item;
        first=first.next;
        if (isEmpty()) last=null;
        N--;
        return item;
    }
    public Iterator<Item> iterator(){
        return new ListIterator();
    }
    private class ListIterator implements Iterator<Item>{
        private Node current=first;
        public boolean hasNext(){
            return current != null;
        }
        public void remove(){}
        public Item next(){
            Item item=current.item;
            current=current.next;
            return item;
        }
    }
}
```



## 排序

习惯性约定

| 方法   | 描述           |
| ------ | -------------- |
| sort() | 排序           |
| show() | 打印内容       |
| less() | 对元素进行比较 |
| exch() | 将元素交换位置 |

验证：谨慎起见，我们会在测试代码中添加一条语句`assert isSorted(a)`来确认排序后的数组元素都是有序的，需要注意的是如果只是用exch()来交换数组的元素，那么这个测试已经足够了，但是如果直接将值存入数组中，这条语句无法提供足够的保证

额外内存使用：怕徐算法可分为两类，1.原地排序算法；2.其他排序算法

数据类型：我们的排序算法模板适用于所有实现了Comparable接口的数据类型，在创建自己的数据类型时，我们只要实现Comparable接口就能保证用例代码可以将其排序，要做到这点，只需要实现一个compareTo()方法来定义目标类型对象的自然次序，这在Java的Comparable接口介绍过

### 初级排序

#### 选择排序

找到数组中最小的元素将与数组第一个元素交换位置，之后再剩下的元素中找到最小的将它与第二个交换位置如此往复知道将整个数组排序。

对于选择排序，大约需要N^2/2次比较和N次交换

特点：1.运行时间与输入无关；2.数据移动是最少的

```java
package sort;

import java.util.Arrays;

public class main {
    public static void main(String[] args) {
        Integer[] a={17,5,4,123,25,22,5,1,6,2,3};
        Selection.sort(a);
        System.out.println(Arrays.toString(a));
    }
}


package sort;

public class Selection {
    public static void sort(Comparable[] a){
        int N=a.length;
        for (int i = 0; i < N; i++) {
            int min=i;
            for (int j = i+1; j < N; j++) {
                if(less(a[j],a[min])) min=j;
            }
            exch(a,i,min);
        }
    }
    private static boolean less(Comparable n1,Comparable n2){//辅助方法
        if (n1.compareTo(n2)==1){
            return false;
        }else return true;
    }
    private static void exch(Comparable[] a,int i,int min){//辅助方法
        Comparable t=a[i];
        a[i]=a[min];
        a[min]=t;
    }
}

>>>
[1, 2, 3, 4, 5, 5, 6, 17, 22, 25, 123]
```

#### 插入排序

适用范围：将一个元素插入到一个有序的元素数组中

当前索引左边的所有元素都是有序的，但它们的最终位置还没有确定，为了给更小的元素腾出空间它们都可能被移动。但当索引到达数组右端时就完成了排序

特点：插入排序所需时间取决于输入中元素的初始顺序，它对部分有序的数组以及倒置数量少的数组时，它可能比本章中其他任何算法都要快

```java
package sort;

public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                //less函数比较大小
                exch(a, j, j - 1);//交换元素位置
            }
        }
    }
    .
    .
    .
}
```

插入算法优化—在内循环中将较大的元素都向右移动而不是交换两个元素

```java
package sort;

public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        int exchange=0;
        for (int i = N-1; i >0 ; i--) {  //向
            if(less(a[i],a[i-1])){
                exch(a,i,i-1);
                exchange++;
            }
        }
        if (exchange==0)return;
        for (int i = 2; i < N; i++) {
            Comparable v =a[i];
            int j=i;
            while(less(v,a[j-1])){
                a[j]=a[j-1];
                j--;
            }
            a[j]=v;
        }
    }
}
```

#### 希尔排序

基于插入排序的快速排序算法

希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序，最终形成有序数组。

希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为*h有序数组*。

————————————————————————————————————————————————

h=4

L    E    E    A    M    H	L	E	P	S	O	L	T	S	X	R

L —————— M —————— P —————— T

​	  E ——————  H—————— S —————— S

​			E———————L —————— O —————— X

​                    A —————— E —————— L —————— R

————————————————————————————————————————————————

实现方法：使用插入排序，将移动元素的距离从1改为h

实际上希尔排序是我们唯一无法准确描述其对于乱序的数组的性能特征的排序方法。

```java
package sort;


public class Shell {
    public static void sort(Comparable[] a){
        int N= a.length;
        int h=1;
        while(h<N/3){   //选定好合适的h
            h=3*h+1;
        }
        while(h>=1){
            for (int i = h; i < N; i++) {//形成h有序数组
                for (int j = i; j >= h && less(a[j],a[j-h]); j-=h) {
                    exch(a,j,j-h);
                }
            }
            h=h/3;  //每运行一次就把h缩小，直到h=1时完成排序
        }
    }
    private static boolean less(Comparable n1, Comparable n2) {
        if (n1.compareTo(n2) == 1) {
            return false;
        } else return true;
    }

    private static void exch(Comparable[] a, int i, int min) {
        Comparable t = a[i];
        a[i] = a[min];
        a[min] = t;
    }
}
```

对于大且复杂的数组，希尔排序的表现明显优于选择排序和插入排序且时间基本是线性的

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1627788812788.jpg" style="zoom: 25%;" />

在后面会介绍到更加高效的排序方法，但对于中等大小的数组，希尔排序的运行时间是可以接受的且其代码量小

### 归并排序

*归并：*将两个有序数组归并成一个更大的有序数组。

优秀性质：它能够保证将任意长度为N的数组排序所需时间和NlogN成正比（快）

主要缺点：所需额外空间和N成正比

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1627897051662.jpg" style="zoom:50%;" />

#### 原地归并的抽象方法

将子数组a[lo..mid]（有序）和a[mid+1..hi]（有序）归并为一个有序的数组并将结果放在a[lo..hi]中

```java
public static void merge(Comparable[] a,int lo,int mid,int hi){
        int i=lo,j=mid+1;      //aux不是在这个方法中命名的
        for (int k = lo; k <= hi; k++) {
            aux[k]=a[k];
        }
        for (int k = lo; k <= hi; k++) {
            if (i>mid) a[k]=aux[j++];
            else if(j>hi) a[k]=aux[i++];
            else if(less(aux[j],aux[i])) a[k]=aux[j++];
            else a[k]=aux[i++];
        }
```

解析：该方法先将所有元素复制到aux[]中，再归并回a[]中。方法在归并时进行了4个判断：1.左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）、4.右半边的当前元素大于等于左半边的当前元素（取左半边的元素）

#### 自顶向下的归并排序

*应用高效算法设计中**分治思想**的最典型的一个例子*

基于原地归并的抽象实现了另一种递归归并，这段递归代码是归纳证明算法能够正确将数组排序的基础：**如果它能将两个子数组排序，它就能通过归并两个子数组让整个数组排序**

```java
package sort;

public class Merge {
    private static Comparable[] aux;  //辅助数组

    public static void sort(Comparable[] a){
        aux=new Comparable[a.length];
        sort(a,0,a.length-1);
    }
    private static void sort(Comparable[] a,int lo,int hi){
        if(hi<=lo) return;
        int mid=lo+(hi-lo)/2;
        sort(a,lo,mid);  //将左半边排序
        sort(a,mid+1,hi); //将右半边排序
        merge(a,lo,mid,hi);//归并结果
    }
    private static void merge(Comparable[] a,int lo,int mid,int hi){
        int i=lo,j=mid+1;
        for (int k = lo; k <= hi; k++) {
            aux[k]=a[k];
        }
        for (int k = lo; k <= hi; k++) {
            if (i>mid) a[k]=aux[j++];
            else if(j>hi) a[k]=aux[i++];
            else if(less(aux[j],aux[i])) a[k]=aux[j++];
            else a[k]=aux[i++];
        }
    }
    private static boolean less(Comparable n1,Comparable n2){
        if (n1.compareTo(n2)==1){
            return false;
        }else return true;
    }
}
```

要对子数组a[lo..hi]进行排序，先将它分为a[lo..mid]和a[mid+1..hi]两部分，分别通过递归调用（不断进行拆分）将他们单独排序，最后将有序的子数组归并为最终的排序结果

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1627959458073.jpg" style="zoom: 50%;" />

归并排序所需时间和NlgN成正比，这和初级排序方法不可同日而语，我们只需要比遍历整个数组多个对数因子的时间就能将庞大的数据排序。

进一步改进：

1. 对小规模子数组使用插入排序

   用不同的方法处理小规模问题能改进大多数递归双发的性能，因为递归会是小规模问题中的方法调用过于频繁，使用插入排序处理小规模子数组（比如长度小于15）一般可以使运行时间缩短10%~15%
   
   ```java
   package sort;
   
   
   public class Merge {
       private static int CUTOFF = 15;
       private static Comparable[] aux;  //辅助数组
   
       public static void sort(Comparable[] a){
           aux=a.clone();
           sort(a,0,a.length-1);
       }
       private static void sort(Comparable[] a,int lo,int hi){
           if(hi<=lo) return;
           if ((hi-lo+1)<=CUTOFF){
               insertionSort(a,lo,hi);
               return;
           }
           int mid=lo+(hi-lo)/2;
           sort(a,lo,mid);
           sort(a,mid+1,hi);
           //加入一个判断，让任意子数组算法的运算时间变为线性的了
           if (less(a[mid+1],a[mid])) merge(a,lo,mid,hi);
       }
       private static void merge(Comparable[] a,int lo,int mid,int hi){
           int i=lo,j=mid+1;
           for (int k = lo; k <=hi; k++) {
               aux[k]=a[k];
           }
           for (int k = lo; k <=hi ; k++) {
               if (i>mid) a[k]=aux[j++];
               else if (j>hi) a[k]=aux[i++];
               else if (less(aux[j],aux[i])) a[k]=aux[j++];
               else a[k]=aux[i++];
           }
       }
       //需要注意插入排序算法中位置参数
       private static void insertionSort(Comparable[] a,int lo,int hi){
           for (int i = lo; i <=hi ; i++) {
               for (int j = i; j >lo&&less(a[j],a[j-1]) ; j--) {
                   exch(a,j,j-1);
               }
           }
       }
       private static boolean less(Comparable n1,Comparable n2){
           return n1.compareTo(n2)<0;
       }
       private static void exch(Comparable[] a,int v,int m){
           Comparable n=a[v];
           a[v]=a[m];
           a[m]=n;
       }
   }
   ```
   
   

#### 自底向上的归并排序

不用递归而是先归微型数组再逐步归并起来变成大数组，这种实现方法比标准递归方法的代码量更少

```java
public class MergeBU {
    private static Comparable[] aux;  //辅助数组
    public static void sort(Comparable[] a){
        int N=a.length;
        aux=new Comparable[a.length];
        for (int sz = 1; sz < N; sz=sz+sz) {//sz子数组大小
            for (int lo = 0; lo < N-sz; lo+=sz+sz) {//lo子数组索引
                merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1,N-1));
            }
        }
    }
}
```

自底向上的归并排序比较适合用链表组织的数据，这样的方法只需要重新组织链接就能将其排序而不需要创建任何新的结点

#### 排序算法的复杂度

命题1：没有任何基于比较的算法能够保证使用少于lg(N!)~Nlg(N)次比较将长度为N的数组排序

归并排序在最坏情况下比较次数为~NlgN——归并排序是一种渐进最优的基于比较排序的算法 

准确的上界为软件工程师保证性能提供了空间，准确的下界可以为我们节省很多时间，避免因不可能的性能改进而投入资源

*归并排序并不是最优解：*

1. 归并排序的空间复杂度不是最优的
2. 在实践中不一定遇到最坏的情况
3. 除了比较，算法的其他操作（例如访问数组）也可能很重要
4. 不进行比较也能将某些数据排序

### 快速排序

可能是应用最为广泛的排序算法。

优点：1.实现简单 2.适用于各种不同的输入数据 3.在一般应用中比其他算法都快得多（与NlgN成正比） 4.是原地排序（只需要一个很小的辅助栈）5.内循环短小

缺点：脆弱，实现时要很小心才能避免低劣的性能

#### 基本算法

将一个数组分成两个子数组然后将二者独立地进行排序（与归并排序是互补的），切分的位置由数组内容决定

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202201092103396.jpg" style="zoom: 33%;" />

切分：`partition(...)`

```java
private static int partition(Comparable[] a,int lo,int hi){
        int i=lo,j=hi+1;
        Comparable v=a[lo];//切分元素
        while(true){
            while(less(a[++i],v)) if(i==hi) break;
            while(less(v,a[--j])) if(j==lo) break;
            if(i>=j) break;
            exch(a,i,j);
        }
        exch(a,lo,j);
        return j;
    }
```

需要注意，快速排序在归并前先对整个数组进行处理，这点是和归并排序互补的

```java
package sort;

public class Quick {
    public static void sort(Comparable[] a){
        sort(a,0,a.length-1);
    }
    private static void sort(Comparable[] a,int lo,int hi){
        if(hi<=lo) return;
        int j=partition(a,lo,hi);//切分
        sort(a,lo,j-1);
        sort(a,j+1,hi);
    }
    
    private static int partition(Comparable[] a,int lo,int hi){
        int i=lo,j=hi+1;
        Comparable v=a[lo];//切分元素
        while(true){
            while(less(a[++i],v)) if(i==hi) break;
            while(less(v,a[--j])) if(j==lo) break;
            if(i>=j) break;
            exch(a,i,j);
        }
        exch(a,lo,j);
        return j;
    }
    private static boolean less(Comparable n1,Comparable n2){
        return n1.compareTo(n2)<0;
    }

    private static void exch(Comparable[] a, int i, int min) {
        Comparable t = a[i];
        a[i] = a[min];
        a[min] = t;
    }
}
```

快速排序的切分方法中内循环将数组元素和一个定值比较，保证了其简洁的特性

*注意：*在切分不平衡时性能会非常低

#### 算法改进

1. 同归并排序，可以在处理小数组时使用插入排序

2. 三取样切分：使用子数组的一部分元素的中位数来切分数组。人民发现取样大小为3且取大小居中的元素切分效果最好

3. 三向切分的快速排序：将与切分元素相等的元素归位，这样它们就不被包含在递归处理的子数组中

   ```java
   private static void sort(Comparable[] a,int lo,int hi){
           if(hi<=lo) return;
           int lt=lo,i=lo+1,gt=hi;
           Comparable v=a[lo];
           while (i<=gt){
               int cmp=a[i].compareTo(v);
               if (cmp<0) exch(a,lt++,i++);
               else if (cmp>0) exch(a,i,gt--);
               else i++;
           }
           sort(a,lo,lt-1);
           sort(a,gt+1,hi);
       }
   ```

### 优先队列

​        与队列（弹出最老元素）和栈（弹出最上层元素）相似，优先队列可以将元素保存其中并且附有一个数值表示其优先程度。优先队列保证在任何时候访问或弹出的总是这个结构里优先级最高的

优先队列需要支持以下两种操作：

1. 删除最大元素
2. 插入元素

#### API

————————————————————————————————————————————————

`public class MaxPQ<Key extends Comparable<key>>`

MaxPQ()                                                      创建一个优先队列

MaxPQ(int max)                                        创建一个初始容量为max的优先队列

MaxPQ(key[] a)                                           用a[]中的元素创建一个优先队列

void insert(key v)                                       向优先队列中插入一个元素

key max()                                                     返回最大元素 

key delMax()                                                删除并返回最大元素

boolean isEmpty()                                      返回队列是否为空

int size()                                                       返回优先队列中的元素个数

————————————————————————————————————————————————

有对max元素进行删除当然也能对min元素进行删除

#### 初级实现

1. 数组实现（无序）：

   加一段类似选择排序的内循环代码，找出最大元素和边界元素替换并删除它

2. 数组实现（有序）：

   在insert()方法中加入代码，将所有较大元素向右边移动一格使数组保存有序（同插入排序一致），这样最大的元素都会落到一边

3. 链表表示法

   基于链表的下压栈为基础，让链表元素逆序并用pop()方法来删除并返回首元素

不过这以上方法都存在着明显的不足：

实现栈或是队列与实现优先队列最大的不同在于对性能的要求。**我们着重说基于堆来实现优先队列**

#### 用堆实现

#### 堆的定义

数据结构二叉堆能够很好地实现优先队列的基本操作，在堆有序的二叉树中，每个结点都小于等于它的父结点。从任意结点往上我们都能得到一列非递减的元素；任意结点往下，我们都能得到一列非递增的元素。

**完全二叉树：**完全二叉树只用数组就能够实现，将二叉树的结点按照层级顺序放入数组中，根在1号位==（0位置不用）==，它的子结点在2,3，子结点的子结点在4,5和6,7。

==在一个堆中 ，位置k的结点的父结点的位置在[k/2],它的两个子结点位置在[2k]和[2k+1]==（通常下标为0的元素会空留出来）

#### 堆的算法

我们使用一个长度为N+1的数组pq[]来表示大小为N的堆，堆元素放在pq[1]至pq[N]中（pq[0]不会使用）

​        在排序算法中我们使用`less()`和`exch()`来访问元素，但是由于所有元素都在数组pq[]中我们在此会使用更为紧凑的方式而不是将数组作为参数传递。**堆的有序化：**1. 首先进行简单改动打破堆的状态   2. 遍历堆并按照要求将堆的状态恢复

堆实现比较和交换方法：

```java
    private boolean less(int i,int j){
        return pq[i].compareTo(pq[j])<0;
    }
    private void exch(int i,int j){
        Key t=pq[i];pq[i]=pq[j];pq[j]=t;
    }
```

##### 由下至上的堆有序化（上浮）

如果堆的状态因为某个结点变得比它的父结点大而被打破，那么我们就要把它同它的父结点交换，但是交换后它仍然可能比它之后的父结点大，我们可以一遍遍地用这样的方法恢复秩序。

```java
private void swim(int k){
        while(k>1&&less(k/2,k)){
            exch(k/2,k);
            k=k/2;
        }
    }
```

##### 由上至下的堆有序化（下沉）

堆的状态因某个父结点变得比它的两个或某一个子结点小而被打破，那么我们需要将它与两个子结点中的较大者交换来恢复堆，同样可能需要不断交换来完成恢复

```java
private void sink(int k){
        while(2*k<=N){   //保证不是在底层
            int j=2*k;   //它的首个子结点索引
            if(j<N&&less(j,j+1)) j++;  //判断两个子结点哪个大
            if(!less(k,j)) break;  //如果父节点不再比子节点小那么就完成了有序化
            exch(k,j)
            k=j;
        }
    }
```

*sink()和swim()方法时实现优先队列API的基础，原因如下：*

1. 插入元素：将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置
2. 删除最大元素：从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置

##### 算法实现：

```java
package sort;

public class MaxPQ<Key extends Comparable<Key>> {
    private Key[] pq;
    private int N=0;
    public MaxPQ(int maxN){
        pq=(Key[]) new Comparable[maxN+1];
    }
    public boolean isEmpty(){
        return N==0;
    }
    public int size(){
        return N;
    }
    public void insert(Key v){
        pq[++N]=v;
        swim(N);
    }
    public Key delMax(){
        Key max=pq[1];
        exch(1,N--);
        pq[N+1]=null;
        sink(1);
        return max;
    }
    private boolean less(int i,int j){
        return pq[i].compareTo(pq[j])<0;
    }
    private void exch(int i,int j){
        Key t=pq[i];pq[i]=pq[j];pq[j]=t;
    }
    private void swim(int k){
        while(k>1&&less(k/2,k)){
            exch(k/2,k);
            k=k/2;
        }
    }
    private void sink(int k){
        while(2*k<=N){   //保证不是在底层
            int j=2*k;   //它的首个子结点索引
            if(j<N&&less(j,j+1)) j++;  //判断两个子结点哪个大
            if(!less(k,j)) break;  //如果父节点不再比子节点小那么就完成了有序化
            exch(k,j)
            k=j;
        }
    }
}
```

**多叉堆**

基于用数组实现的完全三叉堆并修改相应的代码并不复杂，我们需要在树高和在每个结点的d个子结点找到最大者的代价之间找到平衡点。

**调整数组大小**

可以添加一个没有参数的构造方法，在insert()中添加将数组长度加倍的代码，同样在delMax()中加入将数组长度减半的代码，就像栈一样。这样算法的用例就无需关心各种队列大小的限制 

**元素的不可变性**

优先队列存储了用例创建的对象，但同时假设用例代码不会改变它们（改变有可能打破堆的有序性）。但通常我们不会把这个假设变成现实（会让代码更复杂）



#### **索引优先队列**

允许用例引用已经进入优先队列中的元素，要做到这点可以给每个元素一个索引

我们给出以下关联索引的泛型优先队列的API

#### API

————————————————————————————————————————————————

public class IndexMinPQ<Item extends Comparable<Item>>

————————————————————————————————————————————————                      

​                      IndexMinPQ(int maxN)                  创建一个最大容量为maxN的优先队列，

​                                                                                   索引的取值范围为0至maxN-1。

​            void  insert(int k,Item item)                    插入一个元素，将它与索引k相关联

​            void  change(int k,Item item)                 将索引为k的元素设为item

​     boolean  contains(int k)                                  是否存在索引为k的元素

​            void  delete(int k)                                      删去索引为k及其相关联的元素

​           Item  min()                                                  返回最小元素

​              int  minIndex()                                        返回最小元素的索引

​              int  delMin()                                             删除最小元素并返回它的索引

​    boolean  isEmpty()                                           优先队列是否为空、

​              int  size()                                                  优先队列中的元素数量

————————————————————————————————————————————————

#### 用例

下面的用例调用了IndexMaxPQ的代码Multiway解决了*多向归并*问题：它将多个==有序==的输入流归并成一个有序的输出流。

————————————————————————————————————————————————

0 -> f
1 -> a
3 -> c
5 -> r
7 -> g
10-> i

我们将0,1,3,5,7,10称为数据对象的索引

————————————————————————————————————————————————

![](https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/CSDN_1631924781591.jpg)

结点的上标就是其储存位置，结点内的数字为其索引

————————————————————————————————————————————————

```java
public class IndexMinPQ <Key extends Comparable<Key>>{
    private  int maxN;
    private int n;     //元素数量
    private int[] pq;    //输入位置给索引
    private int[]qp;     //逆序：qp[pq[i]]=pq[qp[i]]=i 输入索引给位置
    private Key[] keys;  //有优先级之分的元素，输入索引给元素
    public IndexMinPQ(int maxN){
        this.maxN=maxN;
        keys=(Key[]) new Comparable[maxN+1];
        keys[0]=null;
        n=0;
        pq=new int[maxN+1];
        qp=new int[maxN+1];
        for (int i = 0; i <= maxN; i++) {//将位置数组初始化为-1
            qp[i]=-1;    //当其值为-1时里面没有内容
        }
    }
    public boolean isEmpty(){
        return n==0;
    }
    public boolean contains(int k) {
        return qp[k]!=-1;
    }
    public int size(){
        return n;
    }
    public void insert(int k,Key key){
        n++; //最开始初始化n为0
        qp[k]=n;
        pq[n]=k;
        keys[k]=key;
        swim(n);  //放在了堆底，对其进行上浮操作
    }
    public Key min() {
        return keys[pq[1]];
    }
    public int delMin(){
        int indexOfMin=pq[1];//保存堆顶元素的索引
        exch(1,n--);         //将其与堆底元素交换
        keys[indexOfMin]=null;  //开始消除掉目标元素
        qp[indexOfMin]=-1;
        sink(1);             //对刚换上来的元素进行下沉操作
        return indexOfMin;
    }
    public int minIndex() {
        return pq[1];
    }
    public void change(int k,Key key){  //将内容改变（索引不变）
        keys[k]=key;
        swim(qp[k]);        //不知道它的所处位置所以做一次上浮一次下沉来整理
        sink(qp[k]);
    }
    public void delete(int k){
        int index=qp[k];  //取出其位置
        exch(index,n--);
        swim(index);
        sink(index);
        keys[k]=null;
        qp[k]=-1;
    }
    private boolean greater(int i,int j){
        return keys[pq[i]].compareTo(keys[pq[j]])>0;
        //传入参数大于本参数出1>0 true  i greater than j
    }
    private void exch(int i,int j){
        int temp=pq[i];
        pq[i]=pq[j];
        pq[j]=temp;

        qp[pq[i]]=i;
        qp[pq[j]]=j;
    }
    private void swim(int k){
        while(k>1&&greater(k/2,k)){
            exch(k,k/2);
            k=k/2;
        }
    }
    private void sink(int k){
        while(2*k<=n){   //保证不是在底层
            int j=2*k;   //它的首个子结点索引
            if(j<n&&greater(j,j+1)) j++;  //取较小的结点
            if (!greater(k,j)) break;//如果父结点并没有比较小的结点小就直接跳出
            exch(k,j);
            k=j;
        }
    }
}
```

给出多个有序的输入流，将其整合

```java
import java.io.*;
public class Multiway {
    public static void merge(Reader[] streams)throws Exception{
        int N=streams.length;//N=3;
        IndexMinPQ<String> pq=new IndexMinPQ<>(N);//N=3 大小为3的一个小根堆
        for (int i = 0; i < N; i++) {
            int temp=0;
            if ((temp=streams[i].read())!=-1){
                pq.insert(i,String.valueOf((char)temp)); //元素的索引就是它所在的行数
            }
        }
        while (!pq.isEmpty()){
            System.out.println(pq.min());
            int i=pq.delMin();
            int temp;
            if ((temp=streams[i].read())!=-1){
                pq.insert(i,String.valueOf((char)temp));
            }
        }
    }

    public static void main(String[] args) throws Exception {
        File[] fills=new File[3];
        fills[0]=new File("d:"+File.separator+"h.txt");
        fills[1]=new File("d:"+File.separator+"hh.txt");
        fills[2]=new File("d:"+File.separator+"hhh.txt");
        Reader[] readers=new Reader[fills.length];
        for (int i = 0; i < fills.length; i++) {
            readers[i]=new FileReader(fills[i]);
        }
        merge(readers);
        for (int i = 0; i < fills.length; i++) {
            readers[i].close();
        }
    }
}
```



### 堆排序

**堆排序在排序复杂性的研究中有着重要的地位**，它是我们所知的唯一能够同时最优的利用空间和时间的方法（在空间十分紧张的时候（像嵌入式系统）它很流行，因为只要几行代码就能实现较好的性能，但在现代系统的许多应用中使用很少，因为它无法运用缓存）

我们可以将优先队列变成一种排序算法，将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按照顺序删去

对排序分为两个阶段，在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中，在下沉排序阶段，我们从堆中按照递减顺序取出所有元素并得到排序结果。

在用例中我们使用面向最大元素的优先队列，可以将需要排序的数组本身作为堆，而无需任何额外的空间

#### 堆的构造

一个高效的办法：从右至左用`sink()`函数构造子堆。数组的每一个位置都已经是一个子堆的根节点了，`sink()`对于这些子堆也适用。如果一个结点的两个子结点已经是堆了，那么在该结点上调用`sink()`可以让它们变成一个堆。生过程会递归地建立起堆的秩序

开始时我们只需要扫描数组的一半元素，因为我们可以跳过大小为1的子堆。最后我们在位置1上调用`sink()`方法,扫描结束。

```java
public static void sort(Comparable[] a){
        int N=a.length;
        for (int k = N/2; k >=1 ; k--) {
            sink(a,k,N);
        }
        while (N>1){
            exch(a,1,N--);
            sink(a,1,N);
        }
    }
```

（sink(方法被改造过)）将a[1]到a[N]的元素排序。for循环构造了堆，然后while循环将最大的元素a[1]和a[N]交换并修复了堆，如此重复直到堆变空

![](https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632020418548.jpg)

#### 下沉排序

堆排序的主要工作都是在第二阶段完成的。将最大元素删除，然后放入堆缩小后数组多出来的那个位置（这个过程和选择排序类似）



## 查找

### 符号表

主要目的：将一个键和一个值联系起来。

#### API

————————————————————————————————————————————————public class ST<Key,Value>                                                                                                                                  ————————————————————————————————————————————————

​                      ST()                                                创建一张符号表

​            void  put(Key key,Value value)           将键值对存入表中（若值为空则将键key从表中删除）

​          Value  get(Key key)                                 获取键key对应的值

​            void  delete(Key key)                            从表中删去键key（及其对应的值）

​     boolean  contains(Key key)                        键key在表中是否有对应的值

​     boolean  isEmpty()                                      表是否为空

​              int  size()                                              表中键值对数量

Iterable<Key>  keys()                                     表中的所有键的集合

————————————————————————————————————————————————

注意：

重复的键：

1. 每个键只对应一个值（表中不允许存在重复的键）
2. 但用例代码向表中存入的键值对和表中已有的键冲突时，新的值会替代旧的值

空（null）键：键不能为空。和java中的许多其他机制一样使用空键会产生一个运行异常

空（null）值：规定不能有空值，这样产生了两个我们期望的结果

1. 可以用`get()`方法是否返回空来测试给定的键是否存在于符号表中
2. 可以将空值作为`put()`的第二个参数存入表中来删除键值对

删除操作：符号表中删除有两种实现：







1. 延时删除：将键对于的值设置为空，然后再某个时候删去所有值为空的键
2. 即时删除：立刻从表中删除指定的键

迭代：对于符号表，我们采用了一个较栈和队列更为简单的迭代方法。我们定义了`keys()`方法来返回一个`Iterable<Key>`对象以方便用例遍历所有的键

#### 有序符号表

在典型的应用程序中，键都是Comparable的对象，因此可以对键进行排序让键有序来更好地实现`put()`和`get()`方法。

更重要的是根据键的相对位置定义更多实用性的操作，如：键为时间，我们可以提取一段时间的内容

添加新的API

————————————————————————————————————————————————public class ST<Key extends Comparable<key>,Value>                                                                                                                                  ————————————————————————————————————————————————

​              Key  min()                          最小的键

​             Key  max()                          最大的键

​            Key  floor(Key key)            小于等于key的最大键

​            Key  ceiling(Key key)        大于等于key的最小键

​             int  rank(Key key)            小于key键的数量

​            Key  select(int k)               排名为k的键

​          void  deleteMin()                删除最小键

​         void  deleteMax()                删除最大键

​           int  size(Key lo,Key hi)     [lo..hi]之间键的数量

Iterabel<Key>   keys()                [lo..hi]之间的所有键，已排序

————————————————————————————————————————————————

*键的等价性*：为了避免任何潜在的二义性，我们不会在有序负号表中使用`equals()`方法，而是使用`comparaTo()`方法来比较两个键

基本符号表存在的各种问题：

1. 它不能胜任超大规模的数据存储与搜索
2. 算法低效

符号表应用的特性：

1. 混合使用查找和插入的操作
2. 大量的不同键
3. 查找操作比插入多得多
4. 虽不可预测，但查找和插入操作的使用模式并非随机

无序链表中的顺序查找

​        符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。`get()`的实现即为遍历链表，用`equals()`方法比较需要被查找的键和每个结点中的键，`put()`的实现也是遍历链表并用`equals()`方法比较键。

基于链表的实现以及顺序查找是非常低效的，无法满足FrequencyCounter处理庞大输入问题的需求

```java
public class Seek {
    public class SequentialSearchST<Key,Value>{
        private Node first;
        private class Node{
            Key key;
            Value val;
            Node next;
            public Node(Key key,Value val,Node next){
                this.key=key;
                this.val=val;
                this.next=next;
            }
        }
        public Value get(Key key){
            for (Node x = first; x != null ; x=x.next) {
                if (key.equals(x.key)){
                    return x.val; //命中
                }
            }
            return null;  //未命中
        }
        public void put(Key key,Value val){
            for (Node x = first; x != null ; x=x.next) {
                if (key.equals(x.key)){
                    x.val=val;  //命中 更新
                    return;
                }
            }
            first=new Node(key,val,first); //未命中，新建结点
            return;
        }
    }
}
```

#### 有序数组中的二分查找

其数据结构是一对平行的数组，一个储存键一个储存值

保证键有序然后使用数组的索引来高效实现`get()`方法和其他操作

这份实现的核心是`rank()`方法，它返回表中小于给定键的数量。对于`get()`方法，只要给定的键存在于表中，`rank()`方法就能够精确地告诉我们哪里能够找到它。

同样对于`rank()`方法，也可以通过`rank()`知道要去哪更新它的值

和以前一样，我们可以动态调整数组（注意：你会发现这种方法对于大数组实在是太慢了）

```java
package Seek;

public class BinarySearchST<Key extends Comparable<Key>,Value> {
    private Key[] keys;
    private Value[] vals;
    private int N;
    public BinarySearchST(int capacity){
        keys=(Key[]) new Comparable[capacity];
        vals=(Value[]) new Object[capacity];
    }
    public int size(){
        return N;
    }
    public Value get(Key key){
        if (isEmpty()) return null;
        int i=rank(key);
        if (i<N&&keys[i].compareTo(key)==0){
            return vals[i];
        }
        else return null;
    }
    public void put(Key key,Value val){
        int i=rank(key);
        if (i<N&&keys[i].compareTo(key)==0){
            vals[i]=val;
            return;
        }
        for (int j = N; j > i; j--) {//后挪1位
            keys[j]=keys[j-1];
            vals[j]=vals[j-1];
        }
        keys[i]=key;
        vals[i]=val;
        N++;
    }
    public void delete(Key key){
        int i=rank(key);
        if (i<N&&keys[i].compareTo(key)==0){
            for (int j = i; j < N; j++) {
                keys[j]=keys[j+1];
                vals[j]=vals[j+1];
            }  
        }
    }
    public int rank(Key key){
        int lo=0,hi=N-1;
        while(lo<=hi){
            int mid=lo+(hi-lo)/2;
            int cmp=key.compareTo(keys[mid]);
            if (cmp<0) hi=mid-1;
            else if (cmp>0) lo=mid+1;
            else if (cmp==0) return mid;
        }
        return lo;
    }
    public boolean isEmpty(){
        return N==0;
    }
}
```

**二分查找**

我们使用有序数组储存键的原因：可以利用二分查找根据其索引大大减少每次查找锁需的比较次数。

查找时我们先将被查找的键和子数组的中间键比较，如果被查找的小，就往左子数组继续查找

*递归的二分查找：*

```java
public int rank(Key key,int lo,int hi){
        if (hi<lo) return lo;
        int mid=lo+(hi-lo)/2;
        int cmp=key.compareTo(keys[mid]);
        if (cmp<0) return rank(key,lo,mid-1);
        else if (cmp>0) return rank(key,mid+1,hi);
        else return mid;
    }
```

上面我们使用的是其迭代形式

### 二叉查找树

BST

一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。

使用含有两个链接的链表实现二叉树

#### 基本实现

每个结点包含一个键、一个值、一个左链接、一个右链接和一个结点计数器

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632309234074.jpg" style="zoom: 33%;" />

我们可以把一棵二叉查找树的所有键投影到一条直线上，我们可以发现可以得到一个有序的键列“A  C  E  H  R  S  X”（左键出现在左边右键出现在右边）

##### 查找

从根结点开始查找，目标键比其小继续向左边找，大就继续往右边找，等于命中，如果查找中链接为“null”则没有这个结点

![](https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632309956081.jpg)

```java
package Seek;

public class BST <Key extends Comparable<Key>,Value>{
    private Node root;

    private class Node{
        private Key key;
        private Value val;
        private Node left,right;
        private int N;    //以该结点为根的子树中的结点总数

        public Node(Key key,Value val,int N){
            this.key=key;
            this.val=val;
            this.N=N;
        }
    }
    public int size(){
        return size(root);
    }
    private int size(Node x){
        if (x==null) return 0;
        else return x.N;
    }
    public Value get(Key key){
        return get(root,key);
    }
    private Value get(Node x,Key key){
        if (x==null) return null;
        int cmp=key.compareTo(x.key);
        if (cmp<0) return get(x.left,key);
        else if (cmp>0) return get(x.right,key);
        else return x.val;
    }
    public void put(Key key,Value val){
        root=put(root,key,val);
    }
    private Node put(Node x,Key key,Value val){
        if (x==null) return new Node(key,val,1);
        int cmp= key.compareTo(x.key);
        if (cmp<0) x.left=put(x.left,key,val);
        else if (cmp>0) x.right=put(x.right,key,val);
        else x.val=val;
        x.N=size(x.left)+size(x.right)+1; //更新结点计数
        return x;
    }
}
```

二叉查找树的重要特性：

1. 简洁性
2. 插入的实现难度和查找差不多

和二叉树一样，我们可以构建出有N个子结点的树，某一个N值会获得查找与储存相平衡的性能

#### 有序性相关的方法与删除操作

二叉查找树得以广泛应用的一个重要原因就是它能够保持键的有序性，因此它可以作为实现有序符号表API中的众多方法的基础。

1. 最大键和最小键

   某个结点的左链接为空则其为最小键

   同理某结点右链接为空则其为最大键

2. 向上取整和向下取整

   1. 给定一个key，如果该key比某结点小那么它一定在该结点的左子树中

   2. 如果给定的key大于该结点的key，那么只有当该结点右子树中存在小于等于key的键的结点时，小于等于key的最大键才会出现在右子树中，**否则该结点就是小于等于该key的最大结点**

      <img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632379898273.jpg" style="zoom:33%;" />

```java
    public Key min(){
        return min(root).key;
    }
    private Node min(Node x){
        if (x.left==null) return x;
        return min(x.left);
    }
    public Key max(){
        return max(root).key;
    }
    private Node max(Node x){
        if (x.right==null) return x;
        return max(x.right);
    }
    public Key floor(Key key){
        Node x=floor(root,key);
        if (x==null) return null;
        return x.key;
    }
    private Node floor(Node x,Key key){
        if (x==null) return null;
        int cmp=key.compareTo(x.key);
        if (cmp==0) return x;
        else if (cmp<0) return floor(x.left,key);
        Node t=floor(x.right,key);//如果在右树中一直找不到最后会落空到null
        if (t!=null) return t;
        else return x;
    }
```

3. 选择操作

   二叉查找树中的选择操作和基于切分的数组选择操作类型。我们在二叉查找树的每个结点中维护的子树结点计数器变量N就是用来支持该操作的

   假设我们想找到排名为k的键（即树中正好有k个小于它的键）。
   
   1. 如果左子树的结点数t大于k，那么我们就继续在左子树中寻找；
   2. 等于直接返回根结点的键；
   3. t小于k，就继续在右子树中查找排名为（k-t-1）的键（多减去的1是之前我们查找的那个根节点）

4. 排名

   `rank()`是`select()`的逆方法，它会返回给定键的排名。其实现与`select()`的实现类似

   1. 给定的key等于根结点，返回左子树的结点总数t
   2. 给定的key小于根结点，返回该键在左子树中的排名（递归）
   3. 给定的key大于根结点，返回t+1加上它在右子树中的排名（递归）

```java
    public Key select(int k){
        return select(root,k).key;
    }
    private Node select(Node x,int k){
        if (x==null) return null;
        int t=size(x.left);   //size()函数返回N
        if (t>k) return select(x.left,k);
        else if (t<k) return select(x.right,k-t-1);//进入右侧后左侧不再计算所有要提前减去
        else return x;
    }
    public int rank(Key key){
        return rank(key,root);
    }
    private int rank(Key key,Node x){
        if (x==null) return 0;
        int cmp=key.compareTo(x.key);
        if (cmp<0) return rank(key,x.left);//左边继续寻找
        else if (cmp>0) return 1+size(x.left)+rank(key,x.right);
        //进入右侧前先把左边的结点数进行结算
        else return size(x.left);
    }
```

5. 删除最大键和最小键

   二叉查找树中最难实现的就是删除操作，但是删除最大最小键是最为简单的，最小的在最左下，最大键在最右下，直接将其删去就好，==需要注意更新结点计数器==

6. 删除操作

   我们可以使用和删除最大最小项相似的方法删除只有一个子结点（或者没有子结点）的结点

   对于有两个子结点的结点，删去后使用它的后继结点替代它的位置，这样就能保证其有序性

   1. 将指向即将被删除的结点的链接保存为t
   2. 将x指向它的后继结点min(t.right);
   3. 将x的右链接指向deleteMin(t.right)，（把右子树中最左下和原来的换了位置）
   4. 将x的左链接（本来为空）设为t.left

   <img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/qq_pic_merged_1632388164433.jpg" style="zoom: 50%;" />

```java
    public void deleteMin(){
        root=deleteMin(root);
    }
    private Node deleteMin(Node x){
        if (x.left==null) return x.right;  //当x.left为空时意味着x时最小结点，要把它的右子结点（第二小）的挪到上面变成新的最小
        x.left=deleteMin(x.left);
        x.N=size(x.left)+size(x.right)+1;  //更新计数器
        return x;
    }
    public void delete(Key key){
        root=delete(root,key);
    }
    private Node delete(Node x,Key key){
        if (x==null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp<0) x.left=delete(x.left,key);
        else if (cmp>0) x.right=delete(x.right,key);
        else {   //找到了要删除的键
            //这两个是如果要删除的键在底层的情况
            if (x.right==null) return x.left;
            if (x.left==null) return x.right;
            Node t=x;  //记录下目标结点
            x=min(t.right); //将x指向目标结点右侧最小结点
            x.right=deleteMin(t.right);
            //利用deleteMin()方法将x之前的位置抹掉并将子树与x.right绑定
            x.left=t.left; //左侧子树不变直接移植
        }
        x.N=size(x.left)+size(x.right)+1; //更新计数器
        return x;
    }
```

#### 范围查找

要实现能够返回给定范围内键的keys()方法，我们首先需要一个遍历二叉查找树的基本方法——*中序遍历*。

我们先看怎么把二叉查找树中的键按照顺序打印出来：对于每个结点，我们需要先打印它的左子树然后它自己最后右子树

为了实现给两个参数并将给定范围返回的keys()方法，我们可以将所有落在给定范围的键加入一个人Queue并跳过那些不可能含有所查键的子树。

```java
    public Iterable<Key> keys(){
        return keys(min(),max());
    }
    public Iterable<Key> keys(Key lo,Key hi){
        Queue<Key> queue=new Queue<>();
        keys(root,queue,lo,hi);
        return queue;
    }
    private void keys(Node x,Queue<Key> queue,Key lo,Key hi){
        if (x==null) return;
        int cmplo=lo.compareTo(x.key);
        int cmphi=hi.compareTo(x.key);
        if (cmplo<0) keys(x.left,queue,lo,hi);  //左递归到lo大于等于key
        if (cmplo<=0 && cmphi>=0) queue.enqueue(x.key);//符合条件入队列(由于递归地缘故会先从左边开始入)
        if (cmphi>0) keys(x.right,queue,lo,hi);//右递归到hi小于等于key
    }
}              
```

同时还有集中不同的遍历方法：

1. 前序遍历：先遍历根结点再遍历子结点
2. 中序遍历：根结点在中间遍历==（有序）==
3. 后序遍历：根结点最后遍历
4. 层次遍历，按照数据的层次逐层遍历

#### 性能分析

在随机构造中二叉查找树中所有路径长度都小于3lgN

但如果构造的键不随机——最坏情况下，其恶劣性能是无法接受的



### 平衡查找树

一种二叉查找树并能保证无论如何构造它，它的运行时间都是对数级别的（范围查找除外）

#### 2—3查找树

​        为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切地说，我们将一棵标准的二叉查找树中的结点称为2-结点（含有一个键和两个链接），现在引入==3-结点（含有两个键和三条链接）==

**3-结点**：

1. 左链接指向的树中的键都小于该结点
2. 中链接指向的树中的键都介于该结点两个键之间
3. 右链接指向的树中的键都大于该结点

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632623400655.jpg" style="zoom:50%;" />

一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的

**查找**

与二叉查找树类似，递归地从根结点开始在对应区间内寻找目标键

**向2-结点中插入新键**

先进行一个未命中的查找，如果未命中的查找结束于一个2-结点，那么我们之间将其替换为一个3-结点，将想保存的键放在其中

**向一个只含有一个3-结点的树中插入新键**

1. 临时将新键储存到该结点中使之成为一个4-结点
2. 将它转换为3个2-结点组成2-3树

这棵树既是含有3个结点的二叉查找树，又是一棵完美平衡的2-3树

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632624405522.jpg" style="zoom: 33%;" />

**向一个父结点为2-结点的3-结点中插入新键**

在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间

1. 像刚才一样建立一个临时的4-结点
2. 不会为中键新建一个结点而是将其移动到父结点中
3. 原3-结点中的两键转换为现在父结点的中键与右键变成新的两个2-结点

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632625018097.jpg" style="zoom:33%;" />

**向一个父结点为3-结点的3-结点中插入新键**

1. 将它临时转换为1个4-结点
2. 将它的中键放到它的父结点
3. 父结点重复1-2操作，直到碰到一个2-结点或者到达顶层

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632625638308.jpg" style="zoom: 50%;" />

**分解根结点**

如果插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个临时的4-结点。

我们可以将其分解来解决问题，将其分解成3个2-结点，使树高+1

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/qq_pic_merged_1632626053608.jpg" style="zoom:50%;" />

可以发现这些变换都能保证我们的树依旧是完美平衡的。

和标准二叉查找树的由上向下生长不同，2-3树的生长是由下向上的

不过2-3树直白的表示方法实现大多数的操作并不方便，因为需要处理的情况太多，我们需要维护两种不同的结点，不断将一种数据类型转换为另一种，不仅产生巨大的代码量而且这样产生的额外开销可能导致性能还不如标准二叉查找树，我们需要一种统一的方式



#### 红黑二叉查找树

用来实现我们2-3树的插入算法，需要注意的是在《算法》这本书中红黑二叉树着重还原2-3树的能力一些定义与广泛流传的不完全相同，但是思想是一致的

在2-3树中我们给予了一个结点能够停留插入结点并重新分配的能力，这点使得我们能够对数实现平衡

**替换3-结点**

红黑二叉查找树背后的基本思想就像用标准的二叉查找树和一些额外的信息（替换3-结点）来表示2-3树

我们将树中的链接分为2种类型：

1. 红链接将两个2-结点连接起来构成一个3-结点，在3-结点中的键是有大小的

2. 黑链接则是2-3树中的普通链接

   两个元素对应着3条链，这个就是3-结点中的大中小链接

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632627088080.jpg" style="zoom:33%;" />

**另一种等价的定义：**

1. 红链接均为左链接，这点可能是为了减少需要维护的情况
2. 没有任何一个结点同时和两条红链接相连，防止4-结点的产生
3. 该树是完美黑平衡的

这种表示法的一个优点是我们无需修改就能使用标准二叉树的`get()`方法。对于任意2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。

**颜色表示**

我们将链接的颜色保存在Node数据类型的布尔变量color中，如果==指向它的链接==是红色那就为true，黑色即为false。我们约定空连接为黑

也就是如果这是一个红色结点，那么它的父结点给它的链接就是红色

**旋转**

我们在实现的某些操作中可能会出现红色右链接或者两条红链接，但在操作完成前这些情况都会被小心地旋转并修复。

旋转操作会改变红链接的指向

1. 左旋转：红色右链接—>红色左链接

2. 右旋转：红色左连接—>红色右链接

   旋转重置父结点链接

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632701860812(2).jpg" style="zoom: 33%;" />

右旋：

```java
private Node rotateLeft(Node h){
        Node x=h.right;  //将x指向h右侧由红链接连起来的结点
        h.right=x.left;  //将x左侧和h的右侧绑定
        x.left=h;        //x左侧更新为h结点交换位置
        x.color=h.color; //x换到h位置直接继承其颜色
        h.color=RED;     //h颜色变红
        x.N=h.N;         //x换到了h位置所以直接复制过来
        h.N=1+size(h.left)+size(h.right);//更新h结点计数
        return x;
    }
```

左旋：

```java
private Node rotateRight(Node h){
        Node x=h.left;
        h.left=x.right;
        x.right=h;
        x.color=h.color;
        h.color=RED;
        x.N=h.N;
        h.N=1+size(h.left)+size(h.right);
        return x;
    }
```



**向单个2-结点中插入新键**

向一棵只含有一个2-结点的红黑树中插入一个键，插入后我们需要马上将它们旋转

1. 新键小于老键：生成一个红色结点
2. 新键大于老键：新增的红色结点会产生一条红色右链接，需要`root=rotateleft(root);`将其旋转为红色左链接并修正根节点链接

**向树底部的2-结点中插入新键**

总是用红链接将其与父结点相连，同样如果产生了一个右链接就需要左旋转并重置父结点链接

**向一棵双键树（一个3-结点）中插入新键**

会出现三种情况

1. 大于原树中的两个键：它会被连接到3-结点的右链接，此时将两个红链接全部变黑就成功将其分解了
2. 小于原树中的两个键：连接到最左边的空链接，结果产生了两条连续的红链接。此时需要将上层的红链接右旋转让中值键作为根节点与其他两个相连，变成情况1
3. 新键位于两者之间：需要先将下层红链接左旋转得到情况2，然后右旋转变情况1

 <img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632703408641.jpg" style="zoom:33%;" />

**颜色转换**

我们专门用一个函数`flipColors()`来转换一个结点两个红色子结点的颜色，除了将子结点由红变黑外还要将父结点的颜色由黑变红

```java
void flipColors(Node h){
    h.color=RED;
    h.left.color=BLACK;
    h.right.color=BLACK;
}
```

**根节点总是黑色**

我们每次插入后都会将根节点设为黑色，注意：每当根结点由红变黑时都会让树的黑链接高度+1

**向树底的3-结点中插入新键**

1. 新结点是右链接：只需要转换颜色
2. 新结点是左链接：向右旋转再转换颜色
3. 新结点是中链接：先左旋转下层链接再右旋转上层链接，最后转换颜色

需要注意颜色转换会使到中结点的链接变红，相当于将其送到了父结点中，这与2-3树是一致的

**将红链接在树中向上传递**

在颜色转换中我们实现了红链接的上移

1. 如果右节点是红色而左子结点是黑色则进行左旋转
2. 如果左子结点是红色而且它的左子结点也是红色则进行右旋转
3. 如果左右子结点都为红色，进行颜色转换

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632704910056.jpg" style="zoom:33%;" />

需要注意的是完成颜色转换后父结点的颜色变红了，它将红链接向上传递

##### 实现

因为保持树的平衡性所需的操作时由下向上的，我们只需要在递归调用之后完成这些操作即可

红黑树的插入算法

```java
package Seek;

public class RedBlackBST<Key extends Comparable<Key>,Value> {
    private static final boolean RED=true;
    private static final boolean BLACK=false;
    private Node root;
    private class Node{
        private Key key;
        private Value val;
        private Node left,right;
        private int N;    //以该结点为根的子树中的结点总数
        private boolean color;

        public Node(Key key,Value val,int N,boolean color){
            this.key=key;
            this.val=val;
            this.N=N;
            this.color= color;
        }
    }

    private boolean isRed(Node x){
        if (x==null) return false;
        return x.color==RED;
    }
    private Node rotateLeft(Node h){}
    private Node rotateRight(Node h){}
    private void flipColors(Node h){
        h.color=RED;
        h.left.color=BLACK;
        h.right.color=BLACK;
    }
    public int size(){
        return size(root);
    }
    private int size(Node x) {
        if (x == null) return 0;
        else return x.N;
    }
    public void put(Key key,Value val){
        root=put(root,key,val);
        root.color=BLACK;
    }
    private Node put(Node h,Key key,Value val){
        //除了后面的3条变换语句，实现与二叉查找树一致
        if (h==null) return new Node(key,val,1,RED);
        int cmp=key.compareTo(h.key);
        if (cmp<0) h.left=put(h.left,key,val);
        else if (cmp>0) h.right=put(h.right,key,val);
        else h.val=val;
        //对应3种变换情况
        if (isRed(h.right) && !isRed(h.left)) h=rotateLeft(h);//红色右链接
        if (isRed(h.left) && isRed(h.left.left)) h=rotateRight(h);//连续红链接
        if (isRed(h.left) && isRed(h.right)) flipColors(h);//颜色转换并传递红链接
        
        h.N=1+size(h.left)+size(h.right);
        return h;
    }
}
```

##### 删除操作

红黑树的删除操作是本书最难的实现之一，我们不仅要在（为了删除一个结点）构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点是沿着查找路径向上进行变换

**删除最小键**

可以注意到从树底部3-结点中删除键是最容易的，但删除2-结点比较困难，*即如果最小键结点为红色那么可以直接删除，如果是黑键则会打乱平衡*

为了保证我们不会删除一个2-结点，我们沿着左连接向下进行变换，确保当前结点不是2-结点

**递归进入该结点时该结点不是黑色，变换完后它的子结点不是黑色**

首先根结点可能有两种情况：如果根结点是2-结点且其两个子结点都是2-结点，那么直接将其合成为一个4-结点；否则我们需要保证根结点的左子结点不是2-结点，如果有必要可以用它右侧兄弟结点“借”一个键来

1. 如果当前结点的左子结点不是2-结点，完成
2. 如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，从右侧结点中借一个出来（左旋），让左子结点成为3-结点
3. 如果当前结点（红）的左子结点和它的亲兄弟结点都是2-结点，将左子节点，父结点中的最小键和左子结点最近的兄弟结点合并成一个4-结点，使父结点由3-结点变成2-结点或者4-结点变成3-结点

==可以很明确地发现在这个旋转的过程中结点发生了颜色变化，所以需要我们更新一下这里的旋转操作==

在遍历过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接执行删除操作。然后再向上分解产生的临时4-结点。

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1632745553309.jpg" style="zoom: 50%;" />

由第二行看颜色变化规律：b开始为红，b变黑，a变红，c开始为红挪上去变黑

​                                                                            红b

​                                                               黑a                   黑d——一个4-结点

​                                                                               红c            红e

**删除操作**

在查找路径上进行和删除最小键相同的变换同样可以保证任意当前结点都不是2-结点。

如果目标键在数底部就能直接删除，如果不在就要把它与它的后继结点交换（就和二叉查找树一样）删除完后再向上回溯分解4-结点

**删除最小键**：

在删除的过程中不考虑红黑树的规则问题，只在乎能否维持其完美平衡，具体的规则还原都放在了最后由下向上进行还原

```java
    private void moveFlipColors(Node h){
        h.color=!h.color;
        h.left.color=!h.left.color;
        h.right.color=!h.right.color;
        //在这里即使我们没能完成整个的旋转过程，但是直接进行这一步不会打破红黑树的平衡（黑高没有增加）
    }
    private Node moveRedLeft(Node h){
        //红色左旋
        moveFlipColors(h);//从父结点中借一个(把父结点拉下来了)
        if (isRed(h.right.left)){ //判断兄弟结点左子结点（父结点的后继结点）是不是红的
            h.right=rotateRight(h.right);
            h=rotateLeft(h);//兄弟结点的左红结点经过一次左旋一次右旋到达原来父结点的位置
            moveFlipColors(h); //从父结点借了一个现在要还
        }
        return h;
    }
    public void deleteMin(){
        if (!isRed(root.left) && !isRed(root.right)){
            root.color=RED;//保证遍历时每个当前结点都是红色
            //且如果根结点的左右结点是2-结点，我们可以将根设为红结点，这样才能进行后面的moveRedLeft操作，因为左子结点要从根结点借一个
        }
        root=deleteMin(root);
        if (!isEmpty()) root.color=BLACK; //借完后将根结点颜色还原
    }
    private boolean isEmpty(){
        return root==null;
    }
    private Node deleteMin(Node h){
        if (h.left==null) return null;//遍历到底了，返回null直接将h结点顶掉
        if (!isRed(h.left) && !isRed(h.left.left)){ //判断h的左结点是一个2-结点即它与它的左结点都是黑色
            h=moveRedLeft(h);
        }
        h.left=deleteMin(h.left);//递归地在子左树中变换寻找删除点
        return balance(h); //解除临时4-结点
    }
    private Node balance(Node h){
        if (isRed(h.right) && !isRed(h.left)) h=rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left)) h=rotateRight(h);
        if (isRed(h.left) && isRed(h.right)) flipColors(h);

        h.N=1+size(h.left)+size(h.right);
        return h;
    }
```

**删除最大键：**

在不破坏平衡性和有序性的前提下，将树变成一个含有红色右链接的红黑树，删除最大键后执行恢复操作

和删除最小键一样，我们需要保证递归进入时该结点为红色，出去时它的右子结点变红

从当前结点的父结点入手，向左兄弟结点中借一个出来

```java
    private Node moveRedRight(Node h){
        moveFlipColors(h);  //颜色转换，向父结点借一个
        if (isRed(h.left.left)){//判断其兄弟结点的子结点是否为红色（兄弟结点是不是3-结点）
            //每次都判断兄弟结点的左子结点，因为在借之前，其兄弟结点不可能有红色右链接8
            h=rotateRight(h);//右旋，将准备借的结点拉过来
            moveFlipColors(h);//借了要还
        }
        return h;
    }
    public void deleteMax(){
        if (!isRed(root.left) && !isRed(root.right)){//判断根结点是不是一个2-结点
            root.color=RED;
        }
        root=deleteMax(root);//进入递归
        root.color=BLACK;
    }
    private Node deleteMax(Node h){
        if (isRed(h.left)){ //如果该结点的左结点是红色，那么一次右旋就能直接产生我们需要的红色右子结点
            h=rotateRight(h);
        }
        if (h.right == null) return null;//递归终点
        if (!isRed(h.right) && !isRed(h.right.left)){//右子结点不是红色（之前我们在上面是可能能够生成红色右结点的）且右结点不是一个3-结点
            h=moveRedRight(h);
        }
        h.right=deleteMax(h.right);//下一层递归
        return balance(h);
    }
```

**删除**

1. 从树的根结点开始，如果当前结点小于目标结点那么就在左树中递归删除，递归过程中将红色链接向左传递
2. 如果大于目标结点，需要先判断其左子结点是否为红，是就直接右旋得到红色右结点，否则颜色转换将红色链接向右传递
3. 找到目标结点后判断其右侧是否为空。
   1. 此时待删除结点在树底，通过变换后它是红色的，直接将其删除
   2. 此时待删除结点在中间，采用后继结点替换的方式，找到右子树的最小结点，将其赋给当前结点，然后采用递归删除的方式删除右子树中的最小结点
4. 删除完成后沿路径从下到上修复红色右结点

**有一点需要注意：**不可以在递归的开头定义一个int变量来记录key的比较值，因为在上述操作中第二步右旋会改变树的结构，此时需要重新比较key值

```java
    private Node min(Node x){
        if (x.left==null) return x;
        return min(x.left);
    }
    public void delete(Key key){
        if (key==null) throw new NullPointerException("argument to delete is null");
        if (!isRed(root.left) && !isRed(root.right))
            root.color=RED;
        root=delete(root,key);
        root.color=BLACK;
    }
    private Node delete(Node h,Key key){
        //这里不能使用一个int类型记录键的比较值，后面变换时键值得比较会改变
        if (key.compareTo(h.key)<0){ //左树中查找
            if (!isRed(h.left) && !isRed(h.left.left)) h=moveRedLeft(h);
            //判断左下结点是不是一个2-结点，是的话要将红键向左传递
            h.left=delete(h.left,key);
        } else{//非左树
            if (isRed(h.left)) h=rotateRight(h);//如果它的左边兄弟结点为红，只要一个右旋
            if (key.compareTo(h.key)==0 && h.right==null) return h.left; //要删除的结点在底层
            if (key.compareTo(h.key)==0){//目标结点在中间
                Node t=h;//将后继节点拉上来
                h=min(t.right);
                h.right=deleteMin(t.right);
                h.left=t.left;
            } else{ //在右树中，这里在最后才在右子树中删除，如果将其放在等于之前，node.right.left可能产生空指针错误(缺少递归结束的判断条件)
                if (!isRed(h.right) && !isRed(h.right.left)){
                    h=moveRedRight(h);
                }
                h.right=delete(h.right,key);
            }
        }
        return balance(h);
    }
```

### 散列表

如果所有键都是小整数，我们可以使用一个数组来实现无序符号表，将键作为数组的索引而数组中键i处储存的就是它的值，这样我们就能快速访问任意键的值。

我们需要用算数操作键键转化为数组的索引来访问数组中的键值对。

使用散列的查找算法分为两步：

1. 用散列函将被查找的键转化为数组的一个索引，理想情况下。不同的键都能转化为不同的索引值，当然我们可能需要面对两个或者多个键会散列到同一个索引值的情况
2. 处理碰撞冲突（拉链法和线性探测法）

散列表是时间上和空间上做出权衡的经典例子。

#### 散列函数

散列函数的计算会将键转化为数组的索引。

如果我们有一个能保存M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引的散列函数（[0,M-1]），散列函数应易于计算且均匀分配（与键无关）

严格地说，对于每种类型的键我们都需要一个与之相对应的散列函数。对于许多常见类型的键，我们可以利用java提供的默认实现



*在有性能要求时谨慎使用散列函数，糟糕的散列函数常常是性能问题的罪魁祸首*

##### 典型例子：

1. 正整数

   将整数案例列最常用的方法是*除留余数法*

   我们选择大小为==素数M==的数组，对于任意正整数k，计算k除以M的余数（k%M）并能有效地将键分布到[0,M-1]的范围内

   注意：如果M不是素数，我们可能无法利用键中包含的所有信息，这可能导致我们无法均匀地散列散列值（许多时候我们要进行散列的散列值不是随机的）

2. 浮点数

   有两种方法

   1. 如果键是0-1之间的实数，我们可以将它乘以M并四舍五入得到[0,M-1]之间的索引。这个方法是由缺陷的，在这种情况下高位起的作用明显大于低位
   2. 将键表示为二进制数然后使用*除留余数法*（事实上Java就是这么干的）

3. 字符串

   除留余数法也能处理较长的键，例如字符串，我们只需要将其当做较大的整数即可
   
   ```java
   int hash=0;
   for(int i=0;i<s.length();i++)
       hash=(R * hash+s.charAt(i)) % M 
   ```
   
   `charAt(i)`（i是字符在字符串中的位置）函数能返回一个char值，即一个非负16位整数。如果R比任何字符都大，这种计算相当于将字符串当做一个N位的R进制值，将它除以M并取余。
   
   一种叫做Horner方法的算法用N次乘法、加法和取余来计算一个字符串的散列值。只要R足够小，不会溢出那么结果就能实现散列。使用一个较小的素数（例如31），可以保证字符串中的所有字符都能发挥作用。
   
   java的String的默认方法实现了一个类似的方法
   
4. 组合键

   如果键的类型含有多个整形变量，我们可以像String类一样处理它
   
   例如：键的类型是Data，其中含有day，month，year三个类我们可以这样计算其散列值
   
   `int hash=(((day * R + month) % M) * R + year) % M`

##### java的约定

每种数据类型都需要相应的散列函数，于是java令所有数据类型都继承了一个能够返回一个32比特整数的hashCode()方法。每一种数据类型的hashCode()放吧都必须和equals()方法一致

即：如果`a.equals(b)`返回true，那么两者的hashCode()方法的返回值一致；若两者hashCode()返回值不同，那么这两个对象是不同的（需要注意的是，hashCode()方法返回值一致不代表这两个对象是一样的）

注意：这说明你要为自定义的数据类型定义散列函数，你需要同时重写hashCode()和equals()两个方法，默认的hashCode()会返回对象的内存地址。

java为很多常用的数据类型都重写了hashCode()方法（包括String、Integer、Double、File和URL）

##### 将hashCode()的返回值转化为一个数组索引

其返回值给出的是一个32位的整数，我们需要将其和除留余数法结合产生我们需要的索引值

```java
private int hash(Key x){
    return (x.hashCode() & 0x7fffffff) % M);
    //这段代码会将符号位屏蔽得到一个31位非负整数然后与M取余
}
```

##### 自定义的hashCode()方法

java中重写的hashCode()方法尽可能地实现了得到2的32次方中任意一个32位整数值，我们自己实现的hashCode()方法也应该实现这一点

我们可以和上面的组合类型类似的操作

```java
public class Transaction{
    ...
    private final String who;
    private final Date when;
    private final double amount;
    
    public int hashCode(){
        int hash=17;
        hash=31*hash+who.hashCode();//此处31是系数不重要
        hash=31*hash+when.hashCode();
        hash=31*hash+((Double) amount).hashCode();//原始类型对象需要转换成对应的包装类型
        return hash;
    }
}
```

**软缓存：**即用一个hash变量储存每一个数据的hashCode()返回值，这样每次调用时就不用再重新计算了

#### 基于拉链法的散列表

散列算法的第二部是碰撞处理

一种直接的办法就是将大小为M的数组中每一个元素指向一个链表，链表中储存对应散列值的元素，这就叫拉链法

基于拉链法实现的散列表结构简单，在键的顺序不重要的应用中，它可能是最快的（也是使用最广泛的）符号表实现

链表内部类：

```java
    private class SequentialSearchST<Key,Value>{
        private Node first;
        private int size;

        class Node {
            private Key key;
            private Value val;
            private Node next;

            public Node (Key key,Value val,Node next){
                this.key=key;
                this.val=val;
                this.next=next;
            }
        }

        public Value get(Key key){
            for(Node x=first; x!=null ; x=x.next){
                if (key.equals(x.key)){
                    return x.val;
                }
            }
            return null;
        }
        public void put(Key key,Value val){
            for(Node x=first; x!=null ; x=x.next){
                if (key.equals(x.key)){
                    x.val=val;
                    return;
                }
            }
            //不存在该键就从头部插入
            first=new Node(key,val,first);
            size++;
            return;
        }
        public boolean isEmpty(){
            return size==0;
        }
        public int size(){
            return size;
        }
        public boolean contains(Key key) {
            if (key == null) throw new IllegalArgumentException("argument to contains() is null");
            return get(key) != null;
        }
        public void delete(Key key) {
            if (key == null) throw new IllegalArgumentException("argument to delete() is null");
            first = delete(first, key);
        }
        private Node delete(Node x, Key key) {
            if (x == null) return null;
            if (key.equals(x.key)) {
                size--;
                return x.next;
            }
            x.next = delete(x.next, key);
            return x;
        }
        public Iterable<Key> keys()  {
            //这是为了实现外部类中keys方法而存在的，将链表中的键全部导出
            Queue<Key> queue=new Queue<>();
            while (first!=null){
                queue.enqueue(first.key);
                first=first.next;
            }
            return queue;
        }
    }
```

主数组：

```java
package Seek;

public class SeparateChainingHashST <Key,Value>{
    private int N; //键值对总数
    private int M; //散列表的大小
    private SequentialSearchST<Key,Value>[] st; //存放链表对象的数组
    
    public SeparateChainingHashST(){
        this(997);
    }
    public SeparateChainingHashST(int M){
        this.M=M;
        st=(SequentialSearchST<Key,Value>[])new SequentialSearchST[M];
        for (int i = 0; i < M; i++) {
            st[i]=new SequentialSearchST();
        }
    }

    private int hash(Key key){
        return ((key.hashCode() & 0x7fffffff) % M);
    }
    public Value get(Key key){
        return (Value) st[hash(key)].get(key);
    }
    public void put(Key key,Value val){
        st[hash(key)].put(key,val);
    }
    public Iterable<Key> keys(){
        Queue<Key> queue=new Queue<>();
        for (int i = 0; i < st.length; i++) {
            if (st[i]!=null){
                for (Key key:
                     st[i].keys()) {
                    queue.enqueue(key);
                }
            }
        }
        return queue;
    }
    public void delete(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");

        int i = hash(key);
        if (st[i].contains(key)){
            N--;
            st[i].delete(key);
        }
        //保证链表平均长度在2到8间 此为下界2
        if (N>0 && N<=M*2){
            resize(M/2);
        }
    }
    public boolean contains(Key key){
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");

        int i=hash(key);
        return st[i].contains(key);
    }
    private void resize(int capacity){ //动态调整数组
        //在删除后，如果平均长度N/M低于2，则让数组缩小 一倍：M/2;
        //在加入一个数据后，如果 N/M 高于8，则让数组增加一倍： M*2
        SeparateChainingHashST<Key,Value> hashST=new SeparateChainingHashST<>(capacity);
        for (int i = 0; i < M; i++) {
            for (Key key:st[i].keys()){
                if (key!=null){
                    hashST.put(key,st[i].get(key));
                }
            }
        }
        this.M=hashST.M;
        this.N=hashST.N;
        this.st=hashST.st;
    }
}
```

#### 基于线性探测的散列表

另一种处理碰撞的方法：大小为M的012.3

数组储存N个键值对，M>N。我们需要依靠数组中的空位来解决碰撞冲突。基于这种策略的所有方法称为*开放地址散列表*

开放地址散列表中最简单的方法叫线性探测法，当碰撞发生时，我们直接检查散列表中的下一个位置，这样可能出现3中结果：

1. 命中，该位置的键和被查找的相同
2. 未命中，键为null
3. 继续查找，该位置的键和被查找的不同

我们在实现中使用了并行数组，一条保存键一条保存值

在插入一个值时，先计算键的散列值然后到对应位置寻找，如果该位置有键值对了并且键相同直接更新值，如果键不同就向后寻找一个最近的空位置放入

```java
package Seek;

public class LinearProbingHashST <Key,Value>{
    private int N; //符号表中键值对的总数
    private int M=16; //线性探测表的大小
    private Key[] keys; //键
    private Value[] vals; //值
    
    public LinearProbingHashST(){
        keys=(Key[]) new Object[M];
        vals=(Value[]) new Object[M];
    }
    private LinearProbingHashST(int M){ //用来更新数组大小的
        this.M=M;
        keys=(Key[]) new Object[M];
        vals=(Value[]) new Object[M];
    }
    private int hash(Key key){
        return (key.hashCode() & 0x7fffffff) % M;
    }
    private void resize(int cap){
        LinearProbingHashST<Key,Value> st=new LinearProbingHashST<>(cap);
        for (int i = 0; i < M; i++) {
            st.put(keys[i],vals[i]);
        }
        keys= st.keys;
        vals= st.vals;
        M= st.M;
    }
    public void put(Key key,Value val){
        if (N>=M/2) resize(2*M); //储存空间不足时要扩展
        
        int i;
        for (i = hash(key); keys[i]!=null; i=(i+1) % M) {
            if (keys[i].equals(key)) {
                vals[i]=val;
                return;
            }
        }
        keys[i]=key;
        vals[i]=val;
        N++;
        return;
    }
    public Value get(Key key){
        for (int i = hash(key); keys[i]!=null; i=(i+1) % M) {
            if (keys[i].equals(key))
                return vals[i];
        }
        return null;
    }
}
```

**删除操作**

根据上面的实现我们发现直接删除该键所在位置的键是不行的，这会导致后面来查找时直接落到null然后停止探查。

我们需要将簇中被删除键右侧的所有键重新插入散列表

```java
public void delete(Key key){
        if (!contains(key)) return; //先判断有无此键值对
        int i=hash(key);
        while(!key.equals(keys[i])) i=(i+1) % M;
        keys[i]=null;
        vals[i]=null;
        i=(i+1) % M; //删除后要后挪一位不然直接就落空了
        while(keys[i]!=null){//右边每一项都重新插入
            Key keyToRdo=keys[i];
            Value valToRdo=vals[i];
            keys[i]=null;
            vals[i]=null;
            put(keyToRdo,valToRdo);
            i=(i+1) % M;
        }
        N--;
        if (N>0 && N==M/8) resize(M/2);//调整数组大小
    }
    private boolean contains(Key key){
        for (int i = hash(key); keys[i]!=null ; i=(i+1) % M) {
            if (keys[i].equals(key)) return true;
        }
        return false;
    }
```

可以注意到开放地址类散列表性能也取决于`α=N/M`在此它是使用率，我们动态调整数组来保证使用率在1/8到1/2之间来保证其拥有较好的查找性能

**键簇**

我们将元素锁排列组成的一组连续的条目叫键簇，很明显键簇越短小我们查找的效率越高，当插入元素越来越多时，长键簇会越来越多，经过一系列数学分析我们就得出了使用率在1/8到1/2之间的规则



### KMP字符串匹配算法

用途：就是查找字符串，查找字符串"ab"(目标字符串)在字符串"abc"(待查找字符串)中出现的位置。换句话说，就是查找字符串"abc"是否包含字符串"ab"，如果包含，返回包含的起始位置

**算法由两部分组成**

1. 计算ptr每一位及之前的字符串中，前缀和后缀公共部分的最大长度的next数组
2. 匹配ptr和str，当ptr失配时，利用next数组，实现ptr的最大后移，从而避免不必要的匹配，减少匹配次数

这两个部分的算法实现是非常近似的，都是基于前缀和后缀公共部分来实现的

#### 计算next数组

###### 前缀和后缀公共部分的最大长度

一个字符串`ababa`，他的前缀是可以是`a`,`ab`,`aba`,`abab`(不包含最后一位)，后缀是`a`,`ba`,`aba`,`baba`(不包含第一位)
 前缀后缀公共部分就是`a`和`aba`，公共部分最大就是`aba`，公共部分的最大长度就是3

###### next数组

next数组是ptr每一位及之前的字符串中，前缀和后缀公共部分的最大长度的集合
 比如ptr字符串的长度是11(abxabwabxad)，那么next数组就有11个元素

- next[0]表示ptr前一位`a`中，前缀和后缀公共部分的最大长度，由于`a`中没有前缀和后缀，所以next[0]=0
- next[1]表示ptr前两位`ab`中，前缀和后缀公共部分的最大长度，`ab`的前缀是`a`，后缀是`b`，没有公共部分，所以next[1]=0
   同理
- next[2]=0(`abx`中无公共前后缀)
- next[3]=1(`abxa`公共前后缀最长为`a`，长度为1)
- next[4]=2(`abxab`公共前后缀最长为`ab`，长度为2)
- next[5]=0(`abxabw`中无公共前后缀)
- next[6]=1(`abxabwa`公共前后缀最长为`a`，长度为1)
- next[7]=2(`abxabwab`公共前后缀最长为`ab`，长度为2)
- next[8]=3(`abxabwabx`公共前后缀最长为`abx`，长度为3)
- next[9]=4(`abxabwabxa`公共前后缀最长为`abxa`，长度为4)
- next[10]=0(`abxabwabxad`中无公共前后缀)

<img src="https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img" style="zoom: 50%;" />

- i = 0
   由于字符串的前一位只有一个字符，是没有前后缀的，所以`next[0] = 0`

- i = 1
   从上一次循环，可知 k = 0，既不满足代码中 `k > 0 && findStr[k] != findStr[i]`的判断，也不满足 `findStr[k] == findStr[i]`的判断，所以最后`next[i] = k`，也就是`next[1] = 0`

- i = 2
   同上，k = 0，`next[2] = 0`

- i = 3
   k = 0，满足`findStr[k] == findStr[i]`的判断，执行`k++`，这时 k = 1，最后`next[i] = k`，也就是`next[3] = 1`

- i= 4
   k = 1, 满足`findStr[k] == findStr[i]`的判断，执行`k++`，这时 k = 2，最后`next[i] = k`，也就是`next[4] = 2`

- i = 5
   k = 2，满足 `k > 0 && findStr[k] != findStr[i]`，执行`k = next[k-1]`，k = next[2-1] = next[1] = 0
   很多人（包括我）都很不理解`k = next[k-1]`这行代码的意思，这里先不做解释，后边 i = 10 的时候说

- i = 6...i = 9
   i = 6 到 i = 9 的逻辑和上边相似，就不重复说了，可以参照着图看

- i = 10

  k = 4，满足 `k > 0 && findStr[k] != findStr[i]`，执行`k = next[k-1]`

  ==在这里仔细说下`k = next[k-1]`的意思== **（回到 k 的最长公共前缀）**

  当 i = 9 执行完后，字符串指针为下图的样子，此时前后缀公共部分的最大字符串为

  `abxa`

  <img src="https:////upload-images.jianshu.io/upload_images/11023579-3f9c87552887d198.png?imageMogr2/auto-orient/strip|imageView2/2/w/942/format/webp" alt="img" style="zoom:50%;" />

  再看`abxa`字符串

  字符串的前后缀公共部分的最大字符串为`a`

  所以 i = 9 时，前后缀公共部分可以分解为下图的形式

  <img src="https:////upload-images.jianshu.io/upload_images/11023579-6d42136bdf5fb41b.png?imageMogr2/auto-orient/strip|imageView2/2/w/942/format/webp" alt="img" style="zoom:50%;" />

  所以当 i = 10 时，如果`k > 0 && findStr[k] != findStr[i]`也就是 k指向的b不等于i指向的d，如图

  <img src="https:////upload-images.jianshu.io/upload_images/11023579-21d428236178886a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1025/format/webp" alt="img" style="zoom:50%;" />

  那么k指针就会执行`k = next[k-1]`回到`前缀的公共前缀`

  继续比较，也就是

  <img src="https:////upload-images.jianshu.io/upload_images/11023579-a263069aa241da64.png?imageMogr2/auto-orient/strip|imageView2/2/w/1025/format/webp" alt="img" style="zoom:50%;" />



#### 匹配字符串

使用之前构造的next数组，我们可以知道需匹配字段的最长公共前缀的位置

由于kmp函数和next函数差不多，这里就不详细讲了，直接上图

<img src="https://upload-images.jianshu.io/upload_images/11023579-7132657f716e70e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" />

```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function (haystack, needle) {
    if(needle.length==0) return 0;
    let m = haystack.length;
    let n = needle.length;

    let next = Array(n).fill(0);
    //构造next数组
    let k = 0;
    for (let i = 1; i < n; i++) {
        //如果匹配不成功 k = next[k-1];
        while(k > 0 && needle[k] != needle[i]){
            k = next[k-1];
        }
        if(needle[k] == needle[i]) k++;
        next[i] = k;
    }

    //进行匹配
    for (let i = 0, j = 0; i < m; i++) {
        //如果不匹配 j = next[j-1];
        while(j > 0 && haystack[i] != needle[j]) j = next[j - 1];
        if(haystack[i] == needle[j]) j++
        if(j == n) return i-n+1;
    }

    return -1;
};
```



## 图

解决结点与结点间连接的问题如：沿着这些链接能否从一个结点到另一个结点，有多少结点与目标结点相连，两结点中最短链接是哪个等等

本章中有4中最重要的图模型：

1. 无向图（简单链接）
2. 有向图（连接有方向性）
3. 加权图（连接带有权值）
4. 加权有向图（连接同时具有方向性和有权值）

### 无向图

*定义：图是由一组顶点和一组能够将两个顶点相连的边组成的*

就定义而言顶点叫什么并不重要，但我们需要一个方法来指代这些顶点

一般使用0到V-1来表示一张含有V个顶点的图中的各个顶点。这样约定是为了方便使用数组的索引来编写能够高效访问各个顶点中信息的代码

我们用v-w的记法来表示链接v和w的边，w-v是这条边的另一个表示方法

图可以画出来但是需要注意的是图的定义与绘制出的图像是无关的

**特殊的图：**

我们的定义允许出现下面两种简单而特殊的情况

1. 自环，即一条连接一个顶点和其自身的边
2. 平行边，连接同一对顶点的两条边

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1633788751879.jpg" style="zoom: 33%;" />

数学家常常将含有平行边的图称为多重图，而将没有平行边或自环的称为简单图

实现中允许出现自环和平行边（因为它们会在实际应用中出现）

#### 术语表

1. **相邻、依附**：两个顶点通过一条边相连称这两个顶点*相邻*，并称这条边*依附于*这两个顶点
2. **度数**：依附于这个顶点边的总数
3. **子图**：由一幅图的所有边的一个子集（以及它们锁依附的所有顶点）组成的图
4. **路径**：由边顺序连接的一系列顶点；**简单路径**：一条没有重复顶点的路径；**环**：一条至少含有一条边且起点和终点相同的路径；**简单环**：一条不含有重复顶点和边（除开起点和终点）的环；**长度**：路径或环所包含的边数

在大多数情况下，我们研究的都是简单环和简单路径并会省略“简单”二字。当允许重复的顶点时，我们指的都是一般的路径和环。

5. **连通**：当两个顶点之间存在一条连接双方的路径时，我们称一个顶点与另一个顶点是**连通**的。

我们用类似u-v-w-x的方法记录从u到x的一条路径，u-v-w-x-u表示一个环。

6. **连通图**：从任意一个顶点都存在一条路径到达另一个任意顶点的图。一幅非连通的图由若干连通的部分组成，它们都是其**极大连通子图**

一般来讲，要处理一张图就要一个个地处理它的连通分子量

7. **无环图**：一种不包含环的图
8. **树**：树是一幅无环连通图。互不相连的树组成的集合叫**森林**。连通图的**生成树**是它的一幅子图，它含有图中的所有顶点且是一棵树。图的**生成树森林**是它的所有连通子图的生成树的集合

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1633871530634.jpg" style="zoom:33%;" />

树的定义非常通用，稍做改动就可以用来描述程序行为的（函数调用层次）模型和数据结构（二叉查找树，2-3树等等）

当且仅当一幅含有V个顶点的图G满足以下五个之一时它是一棵树：

1. G有V-1条边且不含环
2. G有V-1条边且是连通的
3. G是连通的，但删除任意以条边都会让其变得不连通
4. G是无环图，但任意添加一条边都会产生一条环
5. G中任意一对顶点之间仅存在一条简单路径

我们会学习几种寻找树和森林的算法，以上这些性质在分析和实现中扮演着重要角色

9. **图的密度**：指已经连接的顶点对占所有可能被连接的顶点对的比例，一般来说，如果一幅图中不同的边的数量在顶点总数V的一个小的常数倍以内，我们认为该图是**稀疏图**（虽然会留下一片灰色地带），但实际应用中稀疏图和**稠密图**之间的区别是十分明显的。我们将会遇到的应用使用几乎都是稀疏图

10. **二分图**：一种能够将所有结点分为两部分的图，其中每条边所连接的两个顶点都分别属于不同的部分

    <img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1633911531659.jpg" style="zoom:33%;" />

红色结点是一个集合，黑色结点是另一个集合

#### 表示无向图的数据类型

无向图的API

————————————————————————————————————————————————public class Graph                                                                                                                                                        ————————————————————————————————————————————————

​                      Graph(int V)                                                        创建一个含有V个顶点但不含有边的图

​                      Graph(In in)                                                        从标准输入流in读入一张图

​               int  V()                                                                         顶点数

​               int  E()                                                                         边数

​            void  addEdge(int v,int w)                                          向图中添加一条边v-w

Iterable<Integre>  adj(int V)                                             和V相邻的所有顶点

​         String  toString()                                                             对象的字符串表示

————————————————————————————————————————————————

本节学习的所有算法都基于adj()方法说抽象的基本操作

第二个构造方法接收的输入由2E+2个整数组成，首先是V然后是E，再然后是E对0到V-1之间的整数，每个整数对都表示一条边

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/mmexport1633913004982.jpg" style="zoom:50%;" />

**图的几种表示方法**

面对的下一个问题就是用那种数据类型来实现这份API

要求：1. 为可能碰到的各种类型的图预留出足够的空间  2. Graph的实例方法的实现一定要快

这些要求比较模糊但是仍然能帮我们在三种图的表示方法中进行选择

1. 邻接矩阵（空间不足舍弃）：我们可以使用一个V*V的布尔矩阵。当顶点v和顶点w之间有相连的边时定义v行w列的元素值为true，否则为false

2. 边的数组（速度不足，需要全部遍历）：使用一个Edge类，它含有两个int实例变量

3. ==邻接表数组==：以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表

   

   <img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110111512405.jpg" style="zoom:33%;" />

   除了性能目标，我们还有一些在某些应用中可能很重要的东西，例如：允许存在平行边相当于排除了邻接矩阵，因为邻接矩阵无法表示它们

##### 邻接表的数据结构

非稠密图的标准表示称为邻接表的数据结构，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张表中。

我们使用这个数组就是为了快速访问给定顶点的邻接顶点列表。这里使用Bag（背包）抽象数据类型来实现这个链表

因为每个顶点都要对应存储，所以每条边会出现两次

这样实现的性能有如下特点：

1. 使用的空间和V+E成正比
2. 添加一条边所需的时间为常数
3. 遍历顶点v的所有相邻顶点所需的时间和v的度数成正比

它的性能已经十分优秀，而且支持处理平行边和自环

注意：边的插入顺序决定了Graph的邻接表中顶点的出现顺序。多个不同的邻接表可能表示同一个图。虽然这不影响adj()的运行（它不检查顺序），但在调试或跟踪邻接表的轨迹时需要注意到这点的影响，为了简化操作，可以从命令行参数指定的文件中读取一幅图并将其打印

```java
public class Graph {
    private int V;  //顶点数目
    private int E;  //边的数目
    private Bag<Integer>[] adj; //邻接表
    public Graph(int V){
        this.V=V;
        this.E=0;
        adj=(Bag<Integer>[]) new Bag[V]; //创建邻接表
        for (int v = 0; v < V; v++) {    //将所有链表初始化
            adj[v]=new Bag<Integer>();
        }
    }
    public Graph(In in){  //根据输入流来进行
        this(in.readInt()); //读取V并将其用于初始化
        int E=in.readInt(); //读取E
        for (int i = 0; i < E; i++) {
            int v=in.readInt();
            int w=in.readInt();
            addEdge(v,w);  //添加边
        }
    }
    public int V(){
        return V;
    }
    public int E(){
        return E;
    }
    public void addEdge(int v,int w){
        adj[v].add(w);
        adj[w].add(v);
        E++;
    }
    public Iterable<Integer> adj(int v){
        return adj[v];
    }
}
```

##### 最常用的图处理代码

1. 计算v的度数

   ```java
   public static int degree(Graph G,int v){
       int degree=0;
       for (int w:
            G.adj(v)) {
           degree++;
       }
       return degree;
   }
   ```

2. 计算所有顶点的最大度数

   ```
   public static int maxDegree(Graph G){
       int max=0;
       for (int v = 0; v < G.V; v++) {
           if (degree(G,v)>max){
               max=degree(G,v);
           }
       }
       return max;
   }
   ```

3. 计算平均度数

4. 计算自环的个数

   ```java
   public static int numberOfSelfLoops(Graph G){
       int count=0;
       for (int v = 0; v < G.V; v++) {
           for (int w:
                G.adj(v)) {
               if (v==w) count++;
           }
       }
       return count/2; //每条边会被记两次
   }
   ```

5. 图的邻接表的字符串表示

   ```java
   public String toString(){
       String s=V+" vertices "+E+" edges\n";
       for (int v = 0; v < V; v++) {
           s+=v+":";
           for (int w:
                this.adj(v)) {
               s+=w+" ";
           }
           s+="\n";
       }
       return s;
   }
   ```

   在实际应用中还有一些操作是很有用的，例如：

   1. 添加一个顶点
   2. 删除一个顶点

   要实现这些操作的一个办法是扩展之前的API，使用符号表（ST）来替代有顶点索引构成的数组（这样修改以后就不用约定顶点必须是整数了）我们可能还需要

   3. 删除一条边
   4. 检查图是否含有边v-w

   要实现这些方法我们还需要用SET来替换Bag来实现邻接表。我们称这种方法为**邻接集**，不过在《算法》中不会对其进行实现（用例不需要，性能损失，算法实现变得复杂）

##### 图的处理算法的设计模式

设计的首要目标是将图的表示和实现分离开。为此我们会为每一个任务创建一个相应的类，用例可以创建相应的对象来完成任务

类的构造函数一般会在预处理中构造各种数据结构，以有效应对用例的请求

————————————————————————————————————————————————public class Search                                                                                                                                             ————————————————————————————————————————————————

​                      Search(Graph G,int s)                                      找到和起点s相连的所有顶点

​     boolean  marked(int v)                                                      v和s是连通的吗

​              int  count()                                                                  与s连通的顶点总数

————————————————————————————————————————————————

我们用起点（source）来区分作为参数传给构造函数的顶点与图中其他顶点

 这份API中marked()方法指的是这种基本算法使用的一种实现方式：在图中从起点开始沿着路径到达其他顶点并标记每个路过的顶点。（本章中会一直使用到这种算法）

#### 深度优先搜索

使用深度优先搜索得到从给定起点到任意标记顶点的路径==所需的时间与路径的长度成正比==

图的许多性质和路径有关，因此一种很自然的是沿着图的边从一个顶点移动到另一个顶点。

##### 走迷宫

思考图的搜索过程的一个有益方法是与跟其等价的走迷宫问题进行观察

探索迷宫的一种古老办法叫*Tremaux搜索*：

1. 选择一条没有标记过的通道，在你走过的路上铺一条绳子
2. 标记所有你第一次路过的路口和通道
3. 当来到一个标记过的路口时（用绳子）回退到上个路口
4. 当回退到的路口已经没有可以走的通道时继续回退

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110131058588.jpg" style="zoom:25%;" />

##### 热身

搜索连通图的经典递归算法（遍历所有顶点和边）和Tremaux搜索类似，但描述起来更加简单，在访问一个顶点时：

1. 将它标记为已访问；
2. 递归地访问它没有被标记过的邻居顶点

这种方法称为深度优先搜索（DFS）

```java
package Graph;

public class DepthFirstSearch {
    private boolean[] marked;
    private int count;
    
    public DepthFirstSearch(Graph G,int s){
        marked=new boolean[G.V()];  //初始化时会自动设置为false
        dfs(G,s);
    }
    private void dfs(Graph G,int v){
        marked[v]=true;
        count++;
        for (int w:
             G.adj(v)) {
            if (!marked[w]) dfs(G,w);
        }
    }
    public boolean marked(int w){
        return marked[w];
    }
    public int count(){
        return count;
    }
}
```

需要注意的是，如果有顶点不与输入顶点相连，那么它是无法被遍历到的

#### 寻找路径

API

————————————————————————————————————————————————

public  class Paths

————————————————————————————————————————————————

​                       Paths(Graph G,int s)                                      在G中找出所有起点为s 的路径

​      boolean  hasPathTo(int v)                                             是否存在从s到v的路径

Iterable<Integer>  pathTo(int v)                                    s到v的路径，如果不存在则返回null

————————————————————————————————————————————————

**实现**

在这份实现中添加了一个edgeTo[]整型数组来起到绳子的作用，这个数组可以找到从每个与s连通的顶点回到s的路径。它会记住每个顶点回到起点的路径而非当前顶点。

edgeTo最终会形成一个由起点为根的树

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110131148660.jpg" style="zoom: 50%;" />

```java
package Graph;

import java.util.Deque;

public class DepthFirstPaths {
    private boolean[] marked; //标记
    private int[] edgeTo; //返回绳子
    private final int s;
    
    public DepthFirstPaths(Graph G,int s){
        marked=new boolean[G.V()];
        edgeTo=new int[G.V()];
        this.s=s;
        dfs(G,s);
    }
    private void dfs(Graph G,int v){
        marked[v]=true;
        for (int w:
             G.adj(v)) {
            if (!marked[w]){
                edgeTo[w]=v;
                dfs(G,w);
            }
        }
    }
    public boolean hasPathTo(int v){
        return marked[v];
    }
    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Deque<Integer> path = new ArrayDeque<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}
```

#### 广度优先搜索

BFS

解决单点路径问题：给定一幅图和一个起点s，从s到给定目的顶点v是否存在一条路径？如果有寻找最短路径

深度优先就像是一个人走迷宫，广度优先则像一组人一起朝各个方向走这个迷宫，每个人都有自己的绳子。当出现新岔路时队列继续分裂为更多的队列继续搜索，当两个探索队相遇时合二为一（并继续使用先到达者的绳子）。

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110132000971.jpg" style="zoom:33%;" />

**实现**

使用一个队列来保存所有已经被标记过当其邻接表还未被检查过的顶点。先将起点加入队列然后重复以下步骤直到队列为空：

1. 取队列中的下一个顶点v并标记它
2. 将与v相邻的所有未被标记过的顶点加入队列

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110132007967.jpg" style="zoom:33%;" />

在这里bfs()方法不是递归的

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110141610137.jpg" style="zoom:50%;" />

```java
package Graph;

import java.util.Deque;

public class BreadthFirstPaths {
    private boolean[] marked;//是否走过这个顶点
    private int[] edgeTo;  //绳子
    private final int s; //起点
    
    public BreadthFirstPaths(Graph G,int s){
        marked=new boolean[G.V()];
        edgeTo=new int[G.V()];
        this.s=s;
        bfs(G,s);
    }
    private void bfs(Graph G,int s){
        Deque<Integer> queue=new ArrayDeque<Integer>();
        marked[s]=true;  //标记起点并将其放入队列
        queue.enqueue(s);
        while(!queue.isEmpty()){
            int v=queue.dequeue();  //从列表中弹出一个
            for (int w:
                 G.adj(v)) {//注意，w如果被标记了根本不会进入后续的操作
                if (!marked[w]){  //对于每一个未被标记的相邻顶点
                    edgeTo[w]=v;  //保存最短路径的最后一条边
                    marked[w]=true; //w标记入队列
                    queue.enqueue(w);
                }
            }
        }
    }
    public boolean hasPathTo(int v){
        return marked[v];
    }
    public Iterable<Integer> pathTo(int v){
        if (!hasPathTo(v)) return null;
        Deque<Integer> path = new ArrayDeque<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}
```

#### 连通分量

深度优先搜索的下一个直接应用就是找出一幅图的说有连通分量

API

————————————————————————————————————————————————public class CC                                                                                                                                                             ————————————————————————————————————————————————

​                      CC(Graph G)                                                        预处理构造函数

​     boolean  connected(int v,int w)                                        v和w连通吗

​              int  count()                                                                   连通分量数

​             int  id(int v)                                                             v所在的连通分量的标识图（0 ~ count()-1）

————————————————————————————————————————————————

用例可以用id()方法将连通分量用数组保存

**实现**

```java
package Graph;

public class CC {
    private boolean[] marked;
    private int[] id;  //用来记录每个连通分量的起点
    private int count;

    public CC(Graph G){
        marked=new boolean[G.V()];
        id=new int[G.V()];
        for (int s = 0; s < G.V(); s++) {
            if (!marked[s]){
                dfs(G,s);
                count++;//每一次进入下一个连通分量计数器加1
            }
        }
    }
    private void dfs(Graph G,int v){
        marked[v]=true;
        id[v]=count;  //记录下v顶点属于第几个连通分量
        for (int w:
             G.adj(v)) {
            if (!marked[w]){
                dfs(G,w);
            }
        }
    }
    public boolean connected(int v,int w){
        return id[v]==id[w];
    }
    public int id(int v){
        return id[v];
    }
    public int count(){
        return count;
    }
}
```

#### union-find算法（动态算法）

union-find算法不需要完整地构造并表示一幅图，且它是一种动态算法（我们在任何时候都能用接近常数的时间检查两个顶点是否连通，甚至在添加一条边的时候）

所以在==只需要判断连通性或者是需要完成有大量连通性查询和插入操作混合==等类似任务时，我们优先选择union-find算法

而深度优先搜索则适合实现图的抽象数据类型，因为它能更为有效地使用已有的数据结构

API

————————————————————————————————————————————————

public class UF

————————————————————————————————————————————————

​                      UF(int N)                                                              以整数标识(0~N-1)初始化N个触点

​           void  union(int p,int q)                                                 在p和q之间添加一条连接

​             int  find(int p)                                                                p（0~N-1）所在的分量标识符

   boolean  connected(int p,int q)                                           判断p和q是否在同一个连通分量中

​             int  count()                                                                     连通分量的数量

————————————————————————————————————————————————

```java
package Graph;

public class UF {
    private int[] id;
    private int count;
    
    public UF(int N){
        count=N;
        id=new int[N];
        for (int i = 0; i < N; i++) {
            id[i]=i;
        }
    }
    public int count(){
        return count;
    }
    public boolean connected(int p,int q){
        return id[p]==id[q];
    }
    public int find(int p){
        return id[p];
    }
    public void union(int p,int q){
        int pID=id[p];
        int qID=id[q];
        if (pID==qID) return;
        //将p所在的分量重命名为q所在的分量名称
        for (int i = 0; i < id.length; i++) {
            if (id[i]==pID) id[i]=qID;
        }
        count--;
    }

    public static void main(String[] args) {//实现用例
        int N=StdIn.readInt(); //读取触点数量
        UF uf=new UF(N);      //初始化N个分量
        while(!StdIn.isEmpty()){
            int p=StdIn.readInt();
            int q=StdIn.readInt();
            if (uf.connected(p,q)) continue;//如果已经连通则跳过
            uf.union(p,q);
            StdOut.println(p+" "+q);//打印连接
        }
        StdOut.println(uf.count()+"components");
    }
}
```

在这里union方法每次调用都需要遍历整个id[]数组，无法处理大型问题

##### quick-union

提高union()方法的速度

简而言之就是从之前的扁平结构变成树形结构，这样如果要将两个相连，直接将它们的根相连就行了

```java
private int root(int p){
    while(p!=id[p]) p=id[p];//不断向上进行查找
    return p;
}
public void union(int p,int q){
    int pRoot=root(p);
    int qRoot=root(q);
    if (pRoot==qRoot) return;
    id[pRoot]=qRoot;
    count--;
}
```

##### 加权quick-union

这是为了解决quick-union中可能出现的最糟糕情况——大树一直往小树连接（这样root()的遍历开销非常大，相当于一个一个遍历了一个链表）

加权后就可以保证一直都是将较小的树连接到大树中

```java
public class WeightedQuickUnionUF {
    private int[] id;
    private int[] sz;  //（由触点索引的）各根节点对应分量的大小
    private int count;
    public WeightedQuickUnionUF(int N){
        count=N;
        id=new int[N];
        sz=new int[N];
        for (int i = 0; i < N; i++) {
            id[i]=i;
            sz[i]=1;
        }
    }
    public int count(){
        return count;
    }
    public boolean connected(int p,int q){
        return root(p)==root(q); 
    }
    public int root(int p){
        while(p!=id[p]) p=id[p];
        return p;
    }
    public void union(int p,int q){
        int pRoot=root(p);
        int qRoot=root(q);
        if (pRoot==qRoot) return;
        if (sz[pRoot]<sz[qRoot]){
            id[pRoot]=qRoot;
            sz[qRoot]+=sz[pRoot];
        }
        else {
            id[qRoot]=pRoot;
            sz[pRoot]+=sz[qRoot];
        }
        count--;
    }
}
```

##### 最优算法

上面可以发现如果能让树里面每个元素都能直接指向根那么root()方法将非常轻量化，但同时要注意避免像基础算法那样进行大量遍历来维护

可以在root()进行查找的同时进行维护

```java
    public int root(int p){
        int q=p;
        while(q!=id[q]) {
            while (p != id[p]) p = id[p];//内循环得到根节点位置
            id[q]=p; //对路径上的节点进行维护
        }
        return p;
    }
```

#### 检测环与双色问题

1.是无环图吗？（假设不存在自环或平行边）

理论：在遍历过程中发现某个结点有一条边指向已经访问过的结点，并且这个已访问结点不是上一步访问的结点则表示存在环

```java
package Graph;

public class Cycle {
    private boolean[] marked;
    private boolean hasCycle;
    public Cycle(Graph G){
        marked=new boolean[G.V()];
        for (int s = 0; s < G.V(); s++) {
            if (!marked[s]) dfs(G,s,s);
        }
    }
    private void dfs(Graph G,int v,int u){
        marked[v]=true;
        for (int w:
             G.adj(v)) {
            if (!marked[w]) dfs(G,w,v);
            else if (w!=u) hasCycle=true; //理论
        }
    }
    public boolean hasCycle(){
        return hasCycle;
    }
}
```



2. 是二分图吗？（双色问题）

   如果我们能将一个图的结点集合分割成两个独立的子集A和B，并使每一条边的两个顶点分别来自A和B则称该图为二分图

```java
package Graph;

public class TwoColor {
    private boolean[] marked;
    private boolean[] color;
    private boolean isTwoColorable=true;
    public TwoColor(Graph G){
        marked=new boolean[G.V()];
        color=new boolean[G.V()];
        for (int s = 0; s < G.V(); s++) {
            if (!marked[s]) dfs(G,s);
        }
    }
    private void dfs(Graph G,int v){
        marked[v]=true;
        for (int w:
             G.adj(v)) {
            if (!marked[w]){
                color[w]=!color[v];
                dfs(G,w);
            }
            else if (color[w]==color[v]) isTwoColorable=false;//染色后两个相连顶点颜色相同
        }
    }
    public boolean isBipartite(){
        return isTwoColorable;
    }
}
```



#### 符号图

在典型应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来指代顶点

定义以下的输入格式：

1. 顶点名为字符串
2. 用指定的分隔符来隔开顶点名（允许顶点名中有空格）
3. 每一行都表示一组边的集合，每条边都连接着这一行的第一个名称表示的顶点和其他顶点
4. 顶点总数V和边的总数E都是隐式定义的（没有显式地指定V和E的值）

这样我们可以在文件内直接增减元素而不用在意维护顶点总数和边数

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110151710422.jpg" style="zoom: 25%;" />

**API**

————————————————————————————————————————————————public class SymbolGraph                                                                                                                                                  ————————————————————————————————————————————————

​                     SymbolGraph(String filename,String delim)       根据filename指定的文件构造图，使用delim来

​                                                                                                         分隔顶点名

​    boolean  contains(String key)                                                 key是一个顶点吗

​              int  index(String key)                                                      key的索引

​        String  name(int v)                                                                索引v的顶点名

​       Graph  G()                                                                               隐藏的Graph对象

————————————————————————————————————————————————

用index()方法将顶点名转化为索引，然后处理结果用name()转化为顶点名

**实现**

它用到了以下3种数据结构：

1. 一个符号表st，键的类型是String（顶点名），值的类型是int（索引）
2. 一个数组keys[]用于反向索引，保存每个顶点索引对应的顶点名
3. 一个Graph对象G，它使用索引来引用图中的顶点

```java
package Graph;

import Seek.RedBlackBST;

public class SymbolGraph {
    private RedBlackBST<String, Integer> st;//符号名——>索引
    private String[] keys;     //索引——>符号名
    private Graph G;          //图

    public SymbolGraph(String stream, String sp) {
        st = new RedBlackBST<>();
        In in = new In(stream);    //第一遍
        while (in.hasNextLine()) { //构造索引
            //读字符串
            String[] a = in.readLine().split(sp);
            for (int i = 0; i < a.length; i++) {
                if (!st.contains(a[i])) {//为每个符号名关联一个索引
                    st.put(a[i], st.size());
                }
            }
        }
        keys = new String[st.size()];  //用来得到反向数组
        for (String name :
                st.keys()) {
            keys[st.get(name)] = name;
        }
        
        G = new Graph(st.size());
        in = new In(stream);       //第二遍
        while (in.hasNextLine()) { //构造图
            String[] a = in.readLine().split(sp);
            int v = st.get(a[0]);  //得到符号名对应的索引
            for (int i = 1; i < a.length; i++) {
                G.addEdge(v, st.get(a[i])); //根据各符号名对应的索引来构造图
            }
        }
    }
    public boolean contains(String s){return st.contains(s);}
    public int index(String s){return st.get(s);}
    public String name(int v){return keys[v];}
    public Graph G(){return G;}
}
```

### 有向图

在有向图中边是单向的

和无向图一样，本章的代码也能处理自环和平行边

#### 术语

1. **出度/入度**：出度为从这个边指出的边总数；入度为从这个边指入的总边数
2. **有向路径/有向环**：由一系列顶点和有向边组成，其中每个顶点都有一条有向边指向下一个顶点；有向环至少含有一条边且起点和终点为同一顶点的有向路径；简单有向环：有向环的基础上它不包含重复的顶点和边的环（除了起点终点相同）

需要注意的是若存在从v—>w的路径时不代表能从w—>v

#### 有向图的数据类型

API

————————————————————————————————————————————————public class Digraph                                                                                                                                                                                             ————————————————————————————————————————————————

​                     Digraph(int V)                                                                创建一幅有V各顶点但是没有边的有向图

​                     Digraph(In in)                                                                根据输入流in生成一张有向图

​              int  V()                                                                                    顶点总数

​              int  E()                                                                                    边的总数

​           void  addEdge(int v,int w)                                                     向有向图中添加一条边V—>w

Iterable<Integer>  adj(int v)                                                         由顶点v指出的边所连接的所有顶点

​    Digraph  reverse()                                                                         该图的反向图

​       String  toString()                                                                         对象的字符串表示

————————————————————————————————————————————————

我们同样使用邻接表来表示有向图，每条边出现一次

**输入格式**：与无向图一样（所以它们的构造函数是一样的，只是在邻接表中每条边只有出现一次（有方向））

**顶点名符号化**：这点也是和无向图几乎完全相同

Digraph数据类型(只有addEdge()方法中只用添加一次)

```java
public void addEdge(int v,int w){
    adj[v].add[w];
    E++;
}
public Digraph reverse(){
    Digraph R=new Digraph(V);
    for(int v=0;v < V; v++){
        for (int w:
             adj(v)) {
            R.addEdge(w,v); //反向   
        }
    }
    return R;
}
```

#### 有向图中的可达性

同样解决单点连通性就使用`DepthFirstSearch`其中的代码与无向图完全相同也可以解决这个问题

DirectedDFS类对其稍加润色实现以下API

————————————————————————————————————————————————public class DirectedDFS                                                                                                                                                      ————————————————————————————————————————————————

​                     DirectedDFS(Digraph G,int s)                                在G中找到从s可达的所有顶点

​                     DirectedDFS(Digraph G,                                         在G中找到从sources中的所有顶点可达的所有

​                                     Iterable<Integer> sources)                顶点

​     boolean  marked(int v)                                                           v是可达的吗

————————————————————————————————————————————————

在添加了一个能接收多个顶点的构造函数之后，这份API能够实现回答*多点可达性*的问题

*多点可达性*：多点到达一点是否存在的问题

```java
package Graph;

public class DirectedDFS {
    private boolean[] marked;

    public DirectedDFS(Digraph G,int s){
        marked=new boolean[G.V()];
        dfs(G,s);
    }
    public DirectedDFS(Digraph G,Iterable<Integer> sources){
        marked=new boolean[G.V()];
        for (int s:
             sources) {
            if (!marked[s]) dfs(G,s);
        }
    }
    private void dfs(Digraph G,int v){
        marked[v]=true;
        for (int w:
             G.adj(v)) {
            if (!marked[w]) dfs(G,w);
        }
    }
    public boolean marked(int v){
        return marked[v];
    }
}
```

*标记—清除的垃圾收集：*java会周期性地运行一个类似于DirectedDFS的有向图可达性算法来标记所有可以被访问到的对象，然后回收没有被标记的对象

##### 有向图的寻路

*深度优先算法*和*广度优先算法*依然是有向图处理中的重要算法，和前面一样*广度优先算法*在有向图中是完全一样的

解决以下问题：1. 单点有向路径         2. 单点最短有向路径

我们分别将深度优先和广度优先命名为：DepthFirstDirectedPaths和BreadthFirstDirectedPaths

##### 再谈可达性

在有向图中可达性问题和强连通问题是不同的，不能用Kosaraju算法直接得到我们期望的结果

API

————————————————————————————————————————————————

public class TransitiveClosure

————————————————————————————————————————————————

​                     TransitiveClosure(Digraph G)                                   预处理的构造函数

​     boolean  reachable(int v,int w)                                                 v可达w吗

————————————————————————————————————————————————

```java
package Graph;

public class TransitiveClosure {
    private DirectedDFS[] all;//每一个元素都构造一个独立的深度优先查找
    public TransitiveClosure(Digraph G){
        all=new DirectedDFS[G.V()];
        for (int v = 0; v < G.V(); v++) {
            all[v]=new DirectedDFS(G,v);
        }
    }
    public boolean reachable(int v,int w){
        return all[v].marked(w);
    }
}
```

事实上这个方法对于稠密图和稀疏图都是理想解决方案

但可以注意到这个算法的初始化需要大量的空间，故其无法处理大型图

#### 环和有向无环图

##### 有向图中的环

一般来说如果一个有优先级限制的问题中出现了环，那么这个问题是无解的

*有向环检测：*一幅有向图中含有的环的数量可能是图的大小的指数倍，所以我们只用找到一个环即可

在任务调度和很多其他的实际应用中不允许环的出现，因此不含环的有向图就变得很特殊

基于深度优先进行搜索，一旦发现有一条有向边v—>w时w已经存在于栈中那么就存在一个环，因为栈表示一条从w到v的有向路径

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110181444430.jpg" style="zoom: 33%;" />

```java
package Graph;

import java.util.Deque;

public class DirectedCycle {
    private boolean[] marked;
    private int[] edgeTo;
    private Deque<Integer> cycle; //有向环中的所有顶点（如果存在）
    private boolean[] onStack;   //递归调用的栈上所有的顶点
    
    public DirectedCycle(Digraph G){
        onStack=new boolean[G.V()];
        edgeTo=new int[G.V()];
        marked=new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G,v);
        }
    }
    private void dfs(Digraph G,int v){
        onStack[v]=true;
        marked[v]=true;
        for (int w:
             G.adj(v)) {
            if (this.hasCycle()) return;//有环直接返回
            else if (!marked[w]) {
                edgeTo[w]=v;
                dfs(G, w);
            }//w没被标记就肯定不在栈里面
            else if (onStack[w]){//在栈中则存在环，将路径中的环记录
                //Stack存入后再弹出会反向，而在edgeTo也是回头遍历的，所以出来的结果就是沿着边的顺序的
                cycle=new ArrayDeque<>();
                for (int x = v; x !=w ; x=edgeTo[x]) {//注意：第二次w是没有入路径绳的
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);//头
            }
            onStack[v]=false;
        }
    }
    public boolean hasCycle(){
        return cycle!=null;
    }
    public Iterable<Integer> cycle(){
        return cycle;
    }
}
```

##### 拓扑排序—调度问题

拓扑排序：给定一幅有向图，将所有的顶点排序使所有的有向边从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110181424549.jpg" style="zoom:25%;" />

API

————————————————————————————————————————————————public class Topological                                                                                                                                                 ————————————————————————————————————————————————

​                      Topological (Digraph G)                                       拓扑排序的构造函数

​      boolean  isDAG()                                                                   G是有向无环图吗

Iterable<Integer>  order()                                                      拓扑有序的所有顶点

————————————————————————————————————————————————

*DepthFirstOrder*有向图中基于深度优先搜索的顶点排序（返回顶点的次序）

1. 前序：在递归调用之前将顶点加入队列
2. 后序：在递归调用之后将顶点加入队列
3. 逆后序：在递归调用之后将顶点压入栈

它实现简单，支持图的高级处理算法中十分有用的`pre()`、`post()`和`reversePost()`方法

```java
package Graph;

import java.util.Deque;

public class DepthFirstOrder {
    private boolean[] marked;
    private Queue<Integer> pre;         //前序排列
    private Queue<Integer> post;        //后序排列
    private Deque<Integer> reversePost; //逆后序排列
    
    public DepthFirstOrder(Digraph G){
        pre=new Queue<Integer>();
        post=new Queue<Integer>();
        reversePost=new ArrayDeque<>();
        marked=new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G,v);
        }
    }
    private void dfs(Digraph G,int v){
        pre.enqueue(v);  //进入递归前
        
        marked[v]=true;
        for (int w:
             G.adj(v)) {
            dfs(G,w);
        }
        post.enqueue(v); //进入递归后
        reversePost.push(v);
    }
    public Iterable<Integer> pre(){
        return pre;
    }
    public Iterable<Integer> post(){
        return post;
    }
    public Iterable<Integer> reversePost(){
        return reversePost;
    }
}
```

拓扑排序

```java
package Graph;

public class Topological {
    private Iterable<Integer> order;
    
    public Topological(Digraph G){
        DirectedCycle cyclefinder=new DirectedCycle(G);
        if (!cyclefinder.hasCycle()){ //判断有无环（有环就实现不了拓扑排序）
            DepthFirstOrder dfs=new DepthFirstOrder(G);
            order=dfs.reversePost(-);
        }
    }
    public Iterable<Integer> order(){
        return order;
    }
    public boolean isDAG(){
        return order!=null;
    }
}
```

#### 有向图中的强连通性

*强连通性：*v—>w的同时也存在w—>v的路径，*自反性：*任何顶点v和自己强连通

强连通<=>在一个环中

##### 强连通分量

强连通性将所有顶点分为了一些等价类，每个都是由相互强连通的顶点的最大子集组成

一个强连通图只含有一个强连通分量，而一个有向无环图中则含有V各强连通分量

API

————————————————————————————————————————————————

public class SCC

————————————————————————————————————————————————

​                     SCC(Digraph G)                                                         预处理构造函数

​    boolean  stronglyConnected(int v,int w)                               v和w强连通吗

​              int  count()                                                                        图中强连通分量的总数

​              int  id(int v)                                                                       v所在的连通分量的标识符（0—count()-1间）

————————————————————————————————————————————————

##### Kosaraju算法

KosarajuCC算法只在CC（计算无向图的连通分量）的基础上添加了几行代码实现了计算强连通分量

它会完成以下任务：

1. 在给定的一幅有向图G中，用DepthFirstOrder来计算它的反向图G^R^的逆后序排列
2. 在G中进行深度优先搜索，但要按照刚才计算得到的顺序而非标准顺序来访问所有未被标记的顶点
3. 在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个*强连通分量*中，将它们按照CC相同的方式识别出来



第一次后序遍历是为了保证第二次对反向图的前序遍历中，先访问到的强连通分量不指向任何未被访问到的强连通分量

图G的反向图G^R^中存在v—>w,就代表G中存在w—>v的有向边。如果在G中按照vw的顺序搜索，若能从v—>w证明v和w强连通，将其强连通标识

```java
package Graph;

public class KosarajuSCC {
    private boolean[] marked;
    private int[] id;        //强连通分量的标识符
    private int count;       //强连通分量的数目
    
    public KosarajuSCC(Digraph G){
        marked=new boolean[G.V()];
        id=new int[G.V()];
        DepthFirstOrder order=new DepthFirstOrder(G.reverse());//得到其反向图的序列信息
        for (int s:
             order.reversePost()) {//反向进行遍历
            if (!marked[s]){
                dfs(G,s);   //同一层在这里能调用到的表示它们在同一个连通分量中
                count++;
            }
        }
    }
    private void dfs(Digraph G,int v){
        marked[v]=true;
        id[v]=count;
        for (int w:
             G.adj(v)) {
            if (!marked[w]) dfs(G,w);
        }
    }
    public boolean stronglyConnected(int v,int w){
        return id[v]==id[w];
    }
    public int id(int v){
        return id[v];
    }
    public int count(){
        return count;
    }
}
```

### 最小生成树

加权图：为每条边关联一个权值

最小生成树：给定一幅加权无向图，找到它的一个最小生成树使其权值最小

一些约定：

+ 只考虑连通图，对于非连通的图，我们只能得到每个连通分量的最小生成树，形成一个最小生成森林

+ 边的权重不一定表示距离

+ 边的权重可以是0或者负数

+ 所有边的权重都各不相同，如果不同边权重可以相同那么最小生成树可能不唯一（不过这个假设并没有限制算法的适用范围，也可以用它来处理等值权重的情况）

+ API

  ——————————————————————————————————————————————

  public class MST 

  ——————————————————————————————————————————————

  ​                      MST(EdgeWeightedGraph G)                     构造函数

  Iterable<Edge>  edges()                                                   最小生成树的所有边

  ​       double  weight()                                                          最小生成树的权重

  ——————————————————————————————————————————————

#### 原理

树的两个最重要的性质：

1. 用一条边连接树种任意两个顶点都会产生一个环
2. 从树中删去一条边都会得到两棵独立的树

##### 切分定理

切分定理：在一幅加权图中，给定任意的切分，它的横切边中权重最小者必然属于图的最小切分图

注意：权重最小的横切边不一定是唯一一个树的横切边

把加权图中的所有顶点分为两个集合，检查横跨两个集合的所有边并识别哪条边应属于图的最小生成树

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110211536329.jpg" style="zoom: 50%;" />

*贪心算法：*切分定理时解决最小生成树的所有算法的基础，这些算法都是一种贪心算法的特殊情况：使用切分定理找到最小生成树的一条边，不断重复知道找到最小生成树的所有边。

#### 加权无向图

在领接矩阵的表示中使用边的权重代替布尔值来作为矩阵的元素

API

————————————————————————————————————————————————

public class Edge implements Comparable<Edge>

————————————————————————————————————————————————

​                      Edge(int v,int w,double weight)                               初始化

​       double  weight()                                                                        边的权重

​               int  either()                                                                         边两端的顶点之一

​               int  other(int v)                                                                  另一个顶点

​               int  compareTo(Edge that)                                              将这条边与另一条边比较

​         String  toString()                                                                     对象的字符串表示

————————————————————————————————————————————————

它是EdgeWeightGraph的基础

```java
package Graph;

public class Edge implements Comparable<Edge>{
    private final int v;
    private final int w;
    private final double weight;
    
    public Edge(int v,int w,double weight){
        this.v=v;
        this.w=w;
        this.weight=weight;
    }
    
    public double weight(){
        return weight;
    }
    public int either(){
        return v;
    }
    public int other(int vertex){
        if (vertex==v) return w;
        else if (vertex==w) return v;
        else throw new RuntimeException("Inconsistent edge");
    }
    public int compareTo(Edge that){
        if (this.weight< that.weight)return -1;
        else if (this.weight>that.weight) return 1;
        else return 0;
    }
    public String toString(){
        return String.format("%d->%d %.2f",v,w,weight);
    }
}
```

加权无向图API

————————————————————————————————————————————————

public class EdgeWeightedGraph

————————————————————————————————————————————————

​                      EdgeWeightedGraph(int V)                              创建一幅含有V个顶点的空图

​                      EdgeWeightedGraph(In in)                              从输入流中读取图

​                int  V()                                                                        图的顶点数

​                int  E()                                                                        图的边数

​             void  addEdge(Edge e)                                               向图中添加一条边

Iterable<Edge>  adj(int v)                                                      和v相关联的所有边

Iterable<Edge>  edges()                                                         图的所有边

​          String  toString()                                                            对象的字符串表示

————————————————————————————————————————————————

这份API与Graph十分相似，不同之处在于此处的基础是Edge且添加了一个edges()方法来遍历所有边，在邻接表中使用Edge对象替换掉了Graph中的整数来作为链表结点

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110251952542.jpg" style="zoom:;" />

```java
package Graph;

public class EdgeWeightedGraph {
    private final int V;
    private int E;
    private Bag<Edge>[] adj;
    
    public EdgeWeightedGraph(int V){
        this.V=V;
        this.E=0;
        adj=(Bag<Edge>[])new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v]=new Bag<Edge>();
        }
    }
    public EdgeWeightedGraph(In in){
        if (in==null) throw new IllegalArgumentException("argument is null");
        V=in.readInt();
        adj=(Bag<Edge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v]=new Bag<Edge>();
        }
        int E=in.readInt();
        if (E<0) throw new IllegalArgumentException("Number of edges must be non-negative");
        for (int i = 0; i < E; i++) {
            int v=in.readInt();
            int w=in.readInt();
            double weight=in.readDouble();
            Edge e=new Edge(v,w,weight);
            addEdge(e);
        }
    }
    public void addEdge(Edge e){
        int v=e.either(),w=e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }
    public Iterable<Edge> adj(int v){
        return adj[v];
    }
    public Iterable<Edge> edges(){
        Bag<Edge> b=new Bag<Edge>();
        for (int v = 0; v < V; v++) {
            for (Edge e:
                 adj[v]) {
                if (e.other(v)>v) b.add(e);//每条边会出现两次，我们只需要记一次
            }
        }
        return b;
    }
}
```



####  Prim算法

*“加点法”*

它的每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入树中

##### 数据结构

+ 顶点：使用一个由顶点索引的布尔数组marked[]，如果顶点v在树中，那么marked[v]值为true
+ 边：选择以下两种数据结构之一：一条队列mst来保存最小生成树的边；或者一个由顶点索引的Edge对象的数组edgeTo[]，其中edgeTo[v]为将v连接到树中的Edge对象
+ 横切边：使用一条优先队列MinPQ<Edge>来根据权重比较所有边

##### 维护横切边的集合

每当我们向树中添加一条边之后也向树中添加了一个顶点，也向树中添加了一个顶点（新加入树中的顶点与其他在树中顶点之间的边都失效了）

##### Prim算法的延时实现

将这样失效的边先留在优先队列之中，等到要删除时再检查有效性

因为失效边没有立即处理，所以在出优先队列时要进行判断该边是否是横切边

```java
package Graph;
import sort.MinPQ;
public class LazyPrimMST {
    private boolean[] marked;//最小生成树的顶点
    private Queue<Edge> mst; //最小生成树的边
    private MinPQ<Edge> pq;  //横切边（包括失效的边）

    public LazyPrimMST(EdgeWeightedGraph G){
        pq=new MinPQ<Edge>();
        marked=new boolean[G.V()];
        mst=new Queue<Edge>();

        visit(G,0);
        while(!pq.isEmpty()){
            Edge e=pq.delMin();    //弹出一个最小边
            int v=e.either(),w=e.other(v);
            if (marked[v]&&marked[w]) continue;//跳过失效的边
            mst.enqueue(e);             //将边加入树中
            if (!marked[v]) visit(G,v); //将顶点（v或w）加入树中
            if (!marked[w]) visit(G,w);
        }
    }
    private void visit(EdgeWeightedGraph G,int v){
        marked[v]=true;//v标记入树中
        for (Edge e:
             G.adj(v)) {//新加入的顶点v与不在树中的顶点所形成的横切边
            if (!marked[e.other(v)]){
                pq.insert(e);
            }
        }
    }
    public Iterable<Edge> edges(){
        return mst;
    }
    public double weight(){
        double weight=0.0;
        for (Edge e:
             mst) {
            weight=weight+e.weight();
        }
        return weight;
    }
}
```

##### Prim算法的即时实现

对于每个非树顶点w我们不需要在优先队列中保存所有从w到树顶点的边（只用需要保存其中权重最小的那条）

我们只保存w与树中顶点连接的最小的那条边

PrimMST使用两个顶点索引的数组edgeTo[]和distTo[]替换掉了marked[]和mst[]

具有如下性质：

+ 如果顶点v不在树中但至少存在一条边与树相连，那么edgeTo[v]是将v和树连接的最短边，distTo[v]是这条边的权重
+ 所有这类顶点都保存在一个索引优先队列中，索引v关联的值是edgeTo[v]边的权重

```java
package Graph;

import Stack.IndexMinPQ;

public class PrimMST {
    private Edge[] edgeTo;    //与树权重最小的边
    private double[] distTo;  //对应边的权重
    private boolean[] marked; //标记顶点在树中
    private IndexMinPQ<Double> pq; //有效横切边
    
    public PrimMST(EdgeWeightedGraph G){
        edgeTo=new Edge[G.V()];
        distTo=new double[G.V()];
        marked=new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            distTo[v]=Double.POSITIVE_INFINITY;
        }
        pq=new IndexMinPQ<>(G.V());
        
        distTo[0]=0.0;
        pq.insert(0,0.0);  //用顶点0和权重0.0初始化pq
        while (!pq.isEmpty()){
            visit(G,pq.delMin()); //将最近的顶点加入到树中
        }
    }
    private void visit(EdgeWeightedGraph G,int v){
        marked[v]=true;
        for (Edge e:
             G.adj(v)) {
            int w=e.other(v);
            if (marked[w])continue;
            if (e.weight()<distTo[w]){
                edgeTo[w]=e;
                distTo[w]=e.weight();
                if (pq.contains(w))pq.change(w,distTo[w]);
                else pq.insert(w,distTo[w]);
            }
        }
    }
    public Iterable<Edge> edges(){
        Queue<Edge> mst=new Queue<Edge>();
        for (int v = 0; v < edgeTo.length; v++) {//就是G.V()，生成树包含着这个图的所有顶点
            Edge e=edgeTo[v];
            if (e!=null){
                mst.enqueue(e);
            }
        }
        return mst;
    }
    public double weight(){
        double weight=0.0;
        for (Edge e:
             edges()) {
            weight+=e.weight();
        }
        return weight;
    }
}
```

#### Kruskal算法

*“加边法”*

按照边的权重顺序（从小到大）处理，将边加入到最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止，这些黑色的边逐渐由一片森林合并为一颗树，也就是最小生成树。

它寻找的边会连接一片森林的两棵树（从v棵单顶点数逐渐合并成一个）

使用一个优先队列将边按照权重排序；一个union-find来识别会形成环的边；一条队列保存最小生成树的边

```java
package Graph;

import sort.MinPQ;

public class KruskalMST {
    private Queue<Edge> mst;
    
    public KruskalMST(EdgeWeightedGraph G){
        mst=new Queue<Edge>();
        MinPQ<Edge> pq=new MinPQ<Edge>();
        for (Edge e :
        G.edges()) {
            pq.insert(e);
        }
        UF uf=new UF(G.V());
        while(!pq.isEmpty()&&mst.size()<G.V()-1){
            Edge e= pq.delMin();
            int v=e.either(),w=e.other(v);
            if (uf.connected(v,w)) continue;//忽略失效的边
            uf.union(v,w);                  //合并分量
            mst.enqueue(e);
        }
    }
    public Iterable<Edge> edges(){
        return mst;
    }
    public double weight(){
        double weight=0.0;
        for (Edge e:
             mst) {
            weight+=e.weight();
        }
        return weight;
    }
}
```

### 最短路径

| 算法                     | 局限                             | 次数（一般） | 次数（最坏） | 所需空间 | 优势                       |
| ------------------------ | -------------------------------- | ------------ | ------------ | -------- | -------------------------- |
| Dijkstra（即时）         | 边的权重必须为正                 | ElogV        | ElogV        | V        | 最坏情况下任然由较好的性能 |
| 拓扑排序                 | 只适用于无环加权有向图           | E+V          | E+V          | V        | 是无环图中的最优算法       |
| Bellman-Ford（基于队列） | 不能存在负权重环（可以进行处理） | E+V          | VE           | V        | 适用领域广泛               |

需要注意的是权重可以是负数，负权重会带来意外的效应

最短路径一般都是简单的，我们的算法会忽略构成环的零权重边，因此找到的路径都不会含有环

最短路径不一定只有一条，我们只需要知道一条就可以

可能存在平行边和自环

**最短路径树：**给出顶点s，计算出一颗最短路径树（SPT）它包含了顶点s到所有可达顶点的最短路径

这样的树使一定存在的：一般来说，从s到一个顶点可能存在两条长度相等的路径，我们可以删除掉第二条的最后一条边，使得保留一条最短路径

#### 加权有向图的数据结构

有向边的数据结构比无向边的更加简单，它只有一个方向

有向边API

————————————————————————————————————————————————

public  class DirectedEdge

————————————————————————————————————————————————

​                      DirectedEdge(int v,int w,double weight)

​       double  weight()                                                                                                边的权重

​               int  from()                                                                                                   指出这条边的顶点

​               int  to()                                                                                                        这条边指向的顶点

​         String  toString()                                                                                              对象的字符串表示

————————————————————————————————————————————————

```java
package Graph;

public class DirectedEdge {
    private final int v;         //边的起点
    private final int w;         //边的终点
    private final double weight; //边的权重
    
    public DirectedEdge(int v,int w,int weight){
        this.v=v;
        this.w=w;
        this.weight=weight;
    }
    public double weight(){
        return weight;
    }
    public int form(){
        return v;
    }
    public int to(){
        return w;
    }
    public String toString(){
        return String.format("%d->%d %.2f",v,w,weight);
    }
}
```



之前从Graph过度到了EdgeWeightedGraph类一样，这类引用edges()方法并使用DirectedEdge类代替了整形变量

API

————————————————————————————————————————————————

public class EdgeWeightedDigraph

————————————————————————————————————————————————

​                     EdgeWeightedDigraph(int V)                                         含有V各顶点的空有向图

​                     EdgeWeightedDigraph(In in)                                         从输入流中读取图

​               int  V()                                                                                      顶点总数

​               int  E()                                                                                      边的总数

​            void  addEdge(DirectedEdge e)                                              将e添加到该有向图中

Iterable<DirectedEdge>  adj(int v)                                                 从v指出的边

Iterable<DirectedEdge>  edges()                                                   该有向图中的所有边

​         String  toString()                                                                          对象的字符串表示

————————————————————————————————————————————————

```java
package Graph;

public class EdgeWeightedDigraph {
    private final int V;              //顶点数
    private int E;                    //边数
    private Bag<DirectedEdge>[] adj;  //邻接表
    
    public EdgeWeightedDigraph(int V){
        this.V=V;
        thisE=0;
        adj=(Bag<DirectedEdge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v]=new Bag<DirectedEdge>();
        }
    }
    public EdgeWeightedDigraph(In in){
        if (in==null) throw new IllegalArgumentException("argument is null");
        this.V=in.readInt();
        int E=in.readInt();
        for (int i = 0; i < E; i++) {
            int v=in.readInt();
            int w=in.readInt();
            double weight=in.readDouble();
            DirectedEdge e=new DirectedEdge(v,w,weight);
            addEdge(e);
        }
    }
    public void addEdge(DirectedEdge e){
        adj[e.form()].add(e);
        E++;
    }
    public int V(){
        return V;
    }
    public int E(){
        return E;
    }
    public Iterable<DirectedEdge> adj(int v){
        return adj[v];
    }
    public Iterable<DirectedEdge> edges(){
        Bag<DirectedEdge> bag=new Bag<DirectedEdge>();
        for (int v = 0; v < V; v++) {
            for (DirectedEdge e:
                 adj(v)) {
                bag.add(e);
            }
        }
        return bag;
    }
}
```

#### 最短路径API

————————————————————————————————————————————————

public class SP

————————————————————————————————————————————————

​                     SP(EdgeWeightedDigraph G)                         构造函数

​      double  distTo(int v)                                                       从顶点s到v的距离，如果路径不存在则其无穷大

​    boolean  hasPathTo(int v)                                               是否存在从s到v的路径

Iterable<DirectedEdge>  pathTo(int v)                          从s到v的路径，如果不存在则为null

————————————————————————————————————————————————

**最短路径的数据结构**

1. 最短路径树中的边：和深度优先、广度优先、Prim算法一样，使用一个由顶点索引的DirectedEdge对象的父链接数组edgeTo[]，**edgeTo[v]表示s到v的最短路径上的最后一条边**
2. 到达起点的距离：我们需要一个顶点索引的数组distTo[]记录每一个点到s的距离，初始化时将其余元素的值均初始化为Double.POSITIVE_INFINITY（无穷大）

#### 边的松弛

最短路径的API实现都基于*松弛*操作

放松边v—>w意味着检查从s到w的最短路径是否是从s到v再由v到w，如果是这样的情况，则根据这个情况更新数据结构的内容

```java
private void relax(DitectedEdge e){
    int v=e.from(),w=e.to();
    if(distTo[w]>distTo[v]+e.weight){
        distTo[w]=distTo[v]+e.weight();
        edgeTo[w]=e;
    }
}
```

s到w的最短路径是distTo[v]+e.weight()——如果这个值不小于distTo[w]，称这条边失效了，并将其忽略

**松弛**这个术语来自于用一根橡皮筋沿着两个顶点绷住的比喻：放松一条边类似于将橡皮筋移到一条更短的路径上，让橡皮筋变松

![](https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110271059005.jpg)

其有效时可能会让其他的边失效

#### 顶点的松弛

事实上，实现会放松从一个顶点指出的所有边

注意：从任意distTo[v]为有限值得顶点v指向任意distTo[]为无穷的顶点的边都是有效的

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110271120953.jpg" style="zoom:50%;" />

```java
private void relax(EdgeWeightedDigraph G,int v){
    for (DirectedEdge e:
         G.adj(v)) {
        int w=e.to();
         f (distTo[w]>distTo[v]+e.weight()){
            distTo[w]=distTo[v]+e.weight();
            edgeTo[w]=e;
        }
    }
}
```

就是在上面的基础上对一个点的所有边都执行了一遍

#### 查询方法

```java
    public double distTo(int v){
        return distTo[v];
    }
    public boolean hasPathTo(int v){
        return distTo[v]<Double.POSITIVE_INFINITY;
    }
    public Iterable<DirectedEdge> pathTo(int v){
        if (!hasPathTo(v)) return null;
        Deque<DirectedEdge> path=new ArrayDeque<DirectedEdge>();//从后往前寻路所以要用栈来让其输出时是由始到末
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from]) {
            path.push(e);
        }
        return path;
    }
```

#### Dijkstra算法

Dijkstra算法使用了和Prim类似的方法来构造最小路径树

除开之前我们提到的数据结构外，它还需要一个索引优先队列pq来保存需要被放松的顶点并确认下一个被放松的顶点

不难发现Dijkstra算法与Prim算法是极为相似的

```java
package Graph;

import Stack.IndexMinPQ;

import java.util.ArrayDeque;
import java.util.Deque;

public class DijkstraSP {
    private DirectedEdge[] edgeTo;  //到达给定顶点的最后一个路径
    private double[] distTo;
    private IndexMinPQ<Double> pq;  //有效横切边

    public DijkstraSP(EdgeWeightedDigraph G,int s){
        edgeTo=new DirectedEdge[G.V()];
        distTo=new double[G.V()];
        pq=new IndexMinPQ<>(G.V());

        for (int v = 0; v < G.V(); v++) {
            distTo[v]=Double.POSITIVE_INFINITY;
        }
        distTo[s]=0.0;
        pq.insert(s,0.0);
        while(!pq.isEmpty()){
            relax(G,pq.delMin());//在这里把最小的横切边从有效的里面删掉并对其进行放松
        }
    }
    private void relax(EdgeWeightedDigraph G,int v){
        for (DirectedEdge e:
             G.adj(v)) {
            int w=e.to();
            if (distTo[w]>distTo[v]+e.weight()){
                distTo[w]=distTo[v]+e.weight();
                edgeTo[w]=e;
                if (pq.contains(w)) pq.change(w,distTo[w]);
                else pq.insert(w,distTo[w]);
            }
        }
    }
    public double distTo(int v){
        return distTo[v];
    }
    public boolean hasPathTo(int v){
        return distTo[v]<Double.POSITIVE_INFINITY;
    }
    public Iterable<DirectedEdge> pathTo(int v){
        if (!hasPathTo(v)) return null;
        Deque<DirectedEdge> path=new ArrayDeque<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e!=null  ; e=edgeTo[e.form()]) {
            path.push(e);
        }
        return path;
    }
}
```

#### Acyclic—无环加权有向图中最短路径算法

许多应用中的加权有向图都是不含有有向环的，Acyclic算法比Dijkstra算法更快、更简单

1. 能够在线性时间内解决单点最短路径问题
2. 能够处理负权重的边
3. 能够解决相关问题：如找出最长的路径

Acyclic算法是对无环有向图的拓扑排序算法的扩展

将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大，然后一个个按照拓扑顺序放松所有顶点（也就是线排序再归入）

需要重载Topological算法

```java
    public Topological(EdgeWeightedDigraph G){
        DirectedCycle_Weight cycleFinder=new DirectedCycle_Weight(G);
        if (!cycleFinder.hasCycle()){
            DirectedDFSOrder dfs=new DirectedDFSOrder(G);
            order=dfs.reversePost();
        }
    }//在这里将查找环的算法和深度优先获得相应顺序的算法都进行了重载，具体见下面
```

```java
package Graph;

public class Topological {
    private Iterable<Integer> order;

    public Topological(Digraph G){
        DirectedCycle cycleFinder=new DirectedCycle(G);
        if (!cycleFinder.hasCycle()){
            DepthFirstOrder dfs=new DepthFirstOrder(G);
            order=dfs.reversePost();
        }
    }
    public Topological(EdgeWeightedDigraph G){
        DirectedCycle_Weight cycleFinder=new DirectedCycle_Weight(G);
        if (!cycleFinder.hasCycle()){
            DirectedDFSOrder dfs=new DirectedDFSOrder(G);
            order=dfs.reversePost();
        }
    }
    public Iterable<Integer> order(){
        return order;
    }
    public boolean isDAG(){
        return order!=null;
    }
}
```

重载深度优先返回相应顺序方法（当然可以整合到之前的DepthFirstOrder里面）

```java
package Graph;

import java.util.ArrayDeque;
import java.util.Deque;

public class DirectedDFSOrder {
    private boolean[] marked;
    private Queue<Integer> pre;         //前序排列
    private Queue<Integer> post;        //后序排列
    private Deque<Integer> reversePost; //逆后序排列

    public DirectedDFSOrder(EdgeWeightedDigraph G){
        pre=new Queue<Integer>();
        post=new Queue<Integer>();
        reversePost=new ArrayDeque<>();
        marked=new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G,v);
        }
    }
    private void dfs(EdgeWeightedDigraph G,int v){
        pre.enqueue(v);

        marked[v]=true;
        for (DirectedEdge e :
                G.adj(v)) {
            int w=e.to();
            dfs(G,w);
        }
        post.enqueue(v);
        reversePost.push(v);
    }
    public Iterable<Integer> pre(){
        return pre;
    }
    public Iterable<Integer> post(){
        return post;
    }
    public Iterable<Integer> reversePost(){
        return reversePost;
    }
}
```

查找圆方法重载（因为cycle的数据类型不一样所以没办法整合进原来的）

加权有向图的基础是边不是顶点所以cycle返回顶点是不合适的

```java
package Graph;

import java.util.ArrayDeque;
import java.util.Deque;

public class DirectedCycle_Weight {
    private boolean[] marked;
    private DirectedEdge[] edgeTo;
    private boolean[] onStack;
    private Deque<DirectedEdge> cycle;

    public DirectedCycle_Weight(EdgeWeightedDigraph G){
        marked=new boolean[G.V()];
        edgeTo=new DirectedEdge[G.V()];
        onStack=new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G,v);
        }
    }
    private void dfs(EdgeWeightedDigraph G,int v){
        onStack[v]=true;
        marked[v]=true;
        for (DirectedEdge e:
             G.adj(v)) {
            int w=e.to();
            if (cycle!=null) return;
            else if (!marked[w]){
                edgeTo[w]=e;
                dfs(G,w);
            }
            else if (onStack[w]){//同一条递归路径上碰到了该条之前走过的路
                cycle=new ArrayDeque<DirectedEdge>();
                DirectedEdge f=e;
                while (f.form()!=w){
                    cycle.push(f);
                    f=edgeTo[f.form()];
                }
                cycle.push(f);
                return;
            }
        }
        onStack[v]=false;
    }
    public boolean hasCycle(){
        return cycle!=null;
    }
    public Iterable<DirectedEdge> cycle(){
        return cycle;
    }
}
```

Acyclic算法实现

```java
package Graph;

import java.util.ArrayDeque;
import java.util.Deque;

public class AcyclicSP {
    private DirectedEdge[] edgeTo;//路径
    private double[] distTo;      //权值（到某顶点）

    public AcyclicSP(EdgeWeightedDigraph G,int s){
        edgeTo=new DirectedEdge[G.V()];
        distTo=new double[G.V()];

        for (int v = 0; v < G.V(); v++) {
            distTo[v]=Double.POSITIVE_INFINITY;
        }
        distTo[s]=0.0;

        Topological top=new Topological(G);
        for (int v:            //按照拓扑顺序进行放松
             top.order()) {
            relax(G,v);
        }
    }
    private void relax(EdgeWeightedDigraph G,int v){
        for (DirectedEdge e:
                G.adj(v)) {
            int w=e.to();
            if (distTo[w]>distTo[v]+e.weight()){
                distTo[w]=distTo[v]+e.weight();
                edgeTo[w]=e;
            }
        }
    }
    public double distTo(int v){
        return distTo[v];
    }
    public boolean hasPathTo(int v){
        return distTo[v]< Double.POSITIVE_INFINITY;
    }
    public Iterable<DirectedEdge> pathTo(int v){
        if (!hasPathTo(v)) return null;
        Deque<DirectedEdge> path=new ArrayDeque<DirectedEdge>();
        for (DirectedEdge e = edgeTo[v]; e != null ; e=edgeTo[e.form()]) {
            path.push(e);
        }
        return path;
    }
}
```

我们还可以用最短路径问题的模型来解决另外两个问题

### 最长路径

在无环有向图中寻找最长路径问题，边的权重可正可负

一个简单方法实现：将AcyclicSP中的distTo[]的初始值变为Double.NEGATIVE_INFINITY，并改变relax中的不等式的方向

通过对路径上的每个顶点收紧形成一颗最长路径树

### 并行任务调度

之前提到过的任务调度问题，给定一组任务并安排它们的执行顺序，限制条件包括这些任务的执行方法、起始时间、任务耗时、资源消耗、优先级限制等等

#### 优先级限制下的并行任务调度

给定一组需要完成的任务和每个任务所需的时间，以及一组关于任务完成的向次序的优先级限制。在满足条件的前提下应该如何在若干相同的处理器（数量不限）安排任务并在最短的时间内完成所有任务

之前我们默认是单处理器，现在我们由多个处理器只是受到优先级限制

**关键路径**算法——广泛应用于无数工业软件中的算法，证明这个问题和无环加权有向图中的最长路径问题是等价的

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202110281446061.jpg" style="zoom: 50%;" />

每个任务由组成：从起点开始到任务开始的有向边（权重为0），从任务开始到任务结束的有向边（权重为执行时间），任务结束指向终点的有向边（权重为0）

每一个任务的耗时表示着这个调度方案的一个可能下界（最理想就是把每个的时耗加起来但显然这是不可能的），这时最长的任务序列就是完成所有任务的关键路径，在这份任务中任何任务的延迟启动都会造成项目完成时间延后

优先级限制下的并行任务调度问题的关键路径方法

```java
package Graph;

public class CPM {
    public static void main(String[] args) {
        In in=new In("D:\\jobsPC.txt");
        int N=in.readInt();in.readLine();
        EdgeWeightedDigraph G;
        G=new EdgeWeightedDigraph(2*N+2);
        int s=2*N,t=2*N+1;
        for (int i = 0; i < N; i++) {
            String[] a=in.readLine().split("\\s");//跳过所有空格
            double duration=Double.parseDouble(a[0]);
            G.addEdge(new DirectedEdge(i,i+N,duration));
            G.addEdge(new DirectedEdge(s,i,0.0));
            G.addEdge(new DirectedEdge(i+N,t,0.0));

            for (int j = 1; j < a.length; j++) {
                int successor=Integer.parseInt(a[j]);
                G.addEdge(new DirectedEdge(i+N,successor,0.0));
            }
        }
        AcyclicLP lp=new AcyclicLP(G,s);
        System.out.println("Start times:");
        for (int i = 0; i < N; i++) {
            System.out.printf("%4d:%5.1f\n",i,lp.distTo(i));
        }
        System.out.printf("Finish time:%5.1f\n",lp.distTo(t));
    }
}
Start times:
   0:  0.0
   1: 41.0
   2:123.0
   3: 91.0
   4: 70.0
   5:  0.0
   6: 70.0
   7: 41.0
   8: 91.0
   9: 41.0
Finish time:173.0
```

文件输入：

10
41.0 1 7 9
51.0 2
50.0
36.0
38.0
45.0
21.0 3 8
32.0 3 8
32.0 2
29.0 4 6

#### 相对最后期限限制下的并行任务调度

一般deadline都是相对于第一个任务开始的时间而言的

在任务调度问题中加入新类型的限制：需要某个任务必须在指定的时间点之前开始，即指定和另一个任务的开始时间的相对时间

| 任务 | 相对最后期限 | 相对于任务 |
| ---- | ------------ | ---------- |
| 2    | 12.0         | 4          |
| 4    | 80.0         | 0          |

看第一列，表面上是限制了任务2的时间，实际上是限制了任务4不能在任务2开始前12之前开始，（在这个调度中任务可以往后延迟但是不能提前）

==相对最后期限限制下的并行任务调度是一个加权有向图中的最短路径问题（可能存在环和负权重边）==

如果任务v必须在任务w启动后的d个单位时间内开始，则添加一条从v指向w的负权重为d的边，将所有的边权重取反即可将这个问题转化为一个最短路径问题

**但之前的算法无法解决这个问题：**Dijkstra算法只适用于非负权重的边，Acyclic算法无法处理环

<img src="https://testingcf.jsdelivr.net/gh/XiaMingYu77/My-Markdown-Picture/img/202111011641733.jpg" style="zoom: 50%;" />

### 一般加权有向图中的最短路径问题

可以有弄过来解决*相对最后期限限制下的并行任务调度*问题

我们需要考虑环和负权重边的情况

一个很明显的改变就是有时我们会为了经过负权重的边而*绕弯*

**负权重的环**：当存在负权重环时最短路径问题就失去了其意义（可以绕圈圈得到无穷小的路径）

这意味着我们得到的路径它是简单的

定义一个算法：

1. 对于起点不可达的顶点其最短路径为正无穷
2. 对于起点可达但路径上某一个点在负权重环中，其最短路径为负无穷
3. 对于其他所有顶点，计算最短路径的权重

#### 基于队列的Bellman-Ford算法

在放松时只有上一轮中的distTo[]值发生变化的顶点指出的边才能够改变其他distTo[]元素的值。

我们使用一个FIFO队列来记录这样的顶点

实现：

数据结构：

1. 一条用来保存即将被放松的顶点的队列queue
2. 一个由顶点索引的boolean数组onQ[]用来指示顶点是否在队列中以防止将顶点重复插入队列

```java
package Graph;

import java.util.ArrayDeque;
import java.util.Deque;

public class BellmanFordSP {
    private double[] distTo;          //从起点到某个顶点的路径长度
    private DirectedEdge[] edgeTo;    //从起点到某个顶点的最后一条边
    private boolean[] onQ;            //该顶点是否存在于队列中
    private Deque<Integer> queue;     //正在被放松的顶点
    private int cost;                 //relax()调用的次数
    private Iterable<DirectedEdge> cycle; //edgeTo[]中是否有负权重环

    public BellmanFordSP(EdgeWeightedDigraph G,int s){
        distTo=new double[G.V()];
        edgeTo=new DirectedEdge[G.V()];
        onQ=new boolean[G.V()];
        queue=new ArrayDeque<>();
        for (int v = 0; v < G.V(); v++) {
            distTo[v]=Double.POSITIVE_INFINITY;
        }
        distTo[s]=0.0;
        queue.add(s);
        onQ[s]=true;
        while(!queue.isEmpty() && !hasNegativeCycle()){
            int v=queue.remove();
            onQ[v]=false;
            relax(G,v);
        }
    }
    private void relax(EdgeWeightedDigraph G,int v){
        for (DirectedEdge e:
             G.adj(v)) {
            int w=e.to();
            if (distTo[w]>distTo[v]+e.weight()){
                distTo[w]=distTo[v]+e.weight();
                edgeTo[w]=e;
                if (!onQ[w]){
                    queue.add(w);
                    onQ[w]=true;
                }
            }
            if (cost++ %G.V()==0){//当放松了V轮后才可能存在从起点可达的负权重环
                findNegativeCycle();
            }
        }
    }
    private boolean hasNegativeCycle(){
        return cycle!=null;
    }
    private void findNegativeCycle(){
        int V=edgeTo.length;
        EdgeWeightedDigraph spt;
        spt=new EdgeWeightedDigraph(V);
        for (int v = 0; v < V; v++) {
            if (edgeTo[v]!=null){
                spt.addEdge(edgeTo[v]);
            }
        }
        DirectedCycle_Weight cycleFinder;
        cycleFinder=new DirectedCycle_Weight(spt);
        cycle=cycleFinder.cycle();
    }
    public Iterable<DirectedEdge> negativeCycle(){
        return cycle;
    }
}
```

#### 套汇问题

文件：

5

USD  1          0.741   0.657   1.061   1.005

EUR  1.349   1          0.888   1.433   1.336

GBP  1.521   1.126   1          1.614   1.538

CHF  0.942   0.698   0.619   1           0.953

CAD  0.995   0.732   0.650   1.049   1



找到顶点s到u路径中所有边的权重之积最大者就是我们能套到的最多外汇

在这个样例中存在环的权重之积大于1，那么在这个环里不断套就可以获得（xyz-1）倍的利润

**套汇问题等价于加权有向图中的负权重环检测问题：**取每条边自然对数并取反（变成自然对数后相加变相乘，-ln1=0小于这个数就代表其权重积>1）

目前没有寻找最佳套汇集合的高效算法（图的规模不用很大就能使所需计算量超过计算机的承受能力），但找出任意套汇机会的最快算法仍然是十分重要的

```java
package Graph;

public class Arbitrage {
    public static void main(String[] args) {
        In in=new In("D:\\rates.txt");
        int V= in.readInt();
        String[] name=new String[V];
        EdgeWeightedDigraph G=new EdgeWeightedDigraph(V);
        for (int v = 0; v < V; v++) {
            name[v]=in.readString();//拉一个数组将名字和索引序号绑定
            for (int w = 0; w < V; w++) {
                double rate=in.readDouble();
                DirectedEdge e=new DirectedEdge(v,w,-Math.log(rate));
                G.addEdge(e);
            }
        }
        BellmanFordSP spt=new BellmanFordSP(G,0);
        if (spt.hasNegativeCycle()){
            double stake=1000.0;//假设初始是1000
            for (DirectedEdge e:
                 spt.negativeCycle()) {
                System.out.printf("%10.5f %s",stake,name[e.from()]);
                stake*=Math.exp(-e.weight());//e的n次方，e和ln抵消再取反就得到了之前的汇率
                System.out.printf("= %10.5f %s\n",stake,name[e.to()]);
            }
        }
        else System.out.println("No arbitrage opportunity");
    }
}
1000.00000 USD=  741.00000 EUR
 741.00000 EUR=  658.00800 GBP
 658.00800 GBP= 1000.83017 USD
```

